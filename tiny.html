<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tiny Dash: Infinite</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Lexend+Exa:wght@700&display=swap');
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Lexend Exa', sans-serif; color: white; user-select: none; touch-action: none; }
        canvas { display: block; }

        /* iPhone/Iframe Fix Overlay */
        #interaction-handler { position: absolute; inset: 0; background: #000; z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; }
        
        #ui-layer { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: none; }
        .panel { background: rgba(0,0,0,0.9); padding: 30px; border-radius: 20px; border: 4px solid #0f0; text-align: center; pointer-events: auto; width: 80%; max-width: 350px; display: none; }
        
        h1 { font-size: 28px; margin: 0 0 15px 0; color: #0f0; text-shadow: 0 0 10px #0f0; }
        .btn { background: #0f0; color: #000; padding: 15px 30px; font-size: 20px; border-radius: 12px; cursor: pointer; font-weight: bold; }
        
        #jump-btn { position: absolute; bottom: 30px; right: 30px; width: 90px; height: 90px; background: rgba(0, 255, 0, 0.2); border: 3px solid #0f0; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: #0f0; font-size: 14px; pointer-events: auto; z-index: 50; }
        #stats { position: absolute; top: 15px; left: 15px; font-size: 14px; color: #0f0; }
    </style>
</head>
<body>

    <div id="interaction-handler">
        <h1>TINY DASH</h1>
        <p>Tap to Start</p>
    </div>

    <div id="stats">Score: 0</div>

    <div id="ui-layer">
        <div id="death-screen" class="panel">
            <h1 style="color:#f00;">CRASHED</h1>
            <div class="btn" onclick="resetGame()" style="background:#f00; color:#fff">RETRY</div>
        </div>
    </div>

    <div id="jump-btn">JUMP</div>

    <canvas id="cvs"></canvas>

<script>
const canvas = document.getElementById('cvs');
const ctx = canvas.getContext('2d');
const stats = document.getElementById('stats');
const deathScreen = document.getElementById('death-screen');
const handler = document.getElementById('interaction-handler');

// --- Assets ---
const img = new Image();
img.src = "https://www.dropbox.com/scl/fi/1u1gm1mwkh1mb2rchd33s/IMG_0963.webp?rlkey=rj3qf9ou8sf9dxynvehmy9628&st=4yldxbrf&raw=1";

const menuMusic = new Audio("https://gdcolon.com/assets/audio/menuLoop.mp3");
menuMusic.loop = true;
const gameMusic = new Audio("https://www.dropbox.com/scl/fi/61itpersex7cmrfj8yqig/Tiny.m4a?rlkey=ph9a226cowhhfs7eq54y4twzj&st=d9zecvr7&raw=1");
gameMusic.loop = true;

// --- Settings ---
const TILE = 60;
const SPEED = 7; // Easy Speed
const GRAVITY = 0.7;
const JUMP = -11;

// --- State ---
let active = false;
let dead = false;
let score = 0;
let camX = 0;
let player = { x: 150, y: 0, vy: 0, angle: 0, w: 50, h: 50 };
let obstacles = []; // {x, type} 1=Block, 2=Spike
let mathBg = [];

// --- Infinite Generator ---
function spawnObstacles() {
    let lastX = obstacles.length > 0 ? obstacles[obstacles.length - 1].x : 600;
    while (obstacles.length < 20) {
        lastX += (TILE * (3 + Math.floor(Math.random() * 5))); // Spread out for Easy difficulty
        let type = Math.random() > 0.5 ? 1 : 2; 
        obstacles.push({ x: lastX, type: type });
    }
}

function init() {
    score = 0;
    camX = 0;
    player.y = canvas.height - 150;
    player.vy = 0;
    player.angle = 0;
    obstacles = [];
    spawnObstacles();
    
    mathBg = [];
    for(let i=0; i<30; i++) mathBg.push({ x: Math.random()*2000, y: Math.random()*canvas.height, t: ["π","x","√","∑"][Math.floor(Math.random()*4)] });
}

// --- Interaction (iPhone Fix) ---
handler.addEventListener('click', () => {
    handler.style.display = 'none';
    active = true;
    menuMusic.play().catch(()=>{});
    init();
    gameMusic.play().catch(()=>{});
    loop();
});

function resetGame() {
    dead = false;
    deathScreen.style.display = 'none';
    init();
    gameMusic.currentTime = 0;
    gameMusic.play();
}

let isJumping = false;
const jumpAction = (e) => { if(!dead) isJumping = true; if(e) e.preventDefault(); };
const jumpEnd = () => isJumping = false;

document.getElementById('jump-btn').addEventListener('touchstart', jumpAction);
document.getElementById('jump-btn').addEventListener('touchend', jumpEnd);
document.getElementById('jump-btn').addEventListener('mousedown', jumpAction);
window.addEventListener('mouseup', jumpEnd);
window.addEventListener('keydown', (e) => { if(e.code === 'Space') isJumping = true; });
window.addEventListener('keyup', (e) => { if(e.code === 'Space') isJumping = false; });

function update() {
    if(!active || dead) return;

    camX += SPEED;
    score = Math.floor(camX / 10);
    stats.innerText = "Score: " + score;

    let floor = canvas.height - 100;
    player.vy += GRAVITY;
    player.y += player.vy;

    if(player.y > floor - player.h) {
        player.y = floor - player.h;
        player.vy = 0;
        if(isJumping) player.vy = JUMP;
        player.angle = Math.round(player.angle / (Math.PI/2)) * (Math.PI/2);
    } else {
        player.angle += 0.15;
    }

    // Collision & Cleanup
    spawnObstacles();
    for(let i = obstacles.length - 1; i >= 0; i--) {
        let o = obstacles[i];
        let tx = o.x - camX + 150;
        let ty = floor - TILE;

        // Check Collision
        if(player.x < tx + TILE - 10 && player.x + player.w > tx + 10 && player.y < ty + TILE && player.y + player.h > ty) {
            if(o.type === 1 && player.vy > 0 && player.y + player.h < ty + 25) {
                player.y = ty - player.h;
                player.vy = 0;
                if(isJumping) player.vy = JUMP;
            } else {
                endGame();
            }
        }

        // Remove off-screen
        if(tx < -100) obstacles.splice(i, 1);
    }
}

function endGame() {
    dead = true;
    gameMusic.pause();
    deathScreen.style.display = 'block';
}

function draw() {
    ctx.fillStyle = '#000800';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Math BG
    ctx.fillStyle = '#0f02';
    ctx.font = '20px Courier';
    mathBg.forEach(m => {
        let x = (m.x - camX * 0.2) % (canvas.width + 100);
        ctx.fillText(m.t, x, m.y);
    });

    let floor = canvas.height - 100;

    // Grid
    ctx.strokeStyle = '#0f01';
    for(let x = -(camX%100); x < canvas.width; x+=100) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
    }

    // Ground
    ctx.fillStyle = '#000'; ctx.fillRect(0, floor, canvas.width, 100);
    ctx.strokeStyle = '#0f0'; ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(0, floor); ctx.lineTo(canvas.width, floor); ctx.stroke();

    // Obstacles
    obstacles.forEach(o => {
        let tx = o.x - camX + 150;
        if(o.type === 1) {
            ctx.fillStyle = '#000'; ctx.strokeStyle = '#0f0';
            ctx.fillRect(tx, floor - TILE, TILE, TILE);
            ctx.strokeRect(tx, floor - TILE, TILE, TILE);
        } else {
            ctx.fillStyle = '#f00'; ctx.beginPath();
            ctx.moveTo(tx, floor); ctx.lineTo(tx + TILE/2, floor - TILE); ctx.lineTo(tx + TILE, floor);
            ctx.fill();
        }
    });

    // Player
    ctx.save();
    ctx.translate(player.x + player.w/2, player.y + player.h/2);
    ctx.rotate(player.angle);
    ctx.shadowBlur = 15; ctx.shadowColor = '#0f0';
    ctx.drawImage(img, -player.w/2, -player.h/2, player.w, player.h);
    ctx.restore();
}

function loop() {
    update();
    draw();
    if(active) requestAnimationFrame(loop);
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();
</script>
</body>
</html>
