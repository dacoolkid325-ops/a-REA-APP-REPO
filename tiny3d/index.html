<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<title>Find Tiny's Family</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&family=Baloo+2:wght@700;800&display=swap" rel="stylesheet">
<style>
:root {
  --gold:#FFD166; --blue:#4ECDC4; --red:#FF6B6B; --dark:#1a1a2e; --mid:#16213e;
}
*{box-sizing:border-box;margin:0;padding:0;}
body{overflow:hidden;background:#0a0a1a;font-family:'Nunito',sans-serif;touch-action:none;user-select:none;}
canvas{display:block;width:100vw;height:100vh;}
#ui{position:absolute;inset:0;pointer-events:none;}

/* â”€â”€ MENU â”€â”€ */
#menu{
position:absolute;inset:0;
background:radial-gradient(ellipse at 30% 40%,#0f3460 0%,#0a0a1a 70%);
display:flex;flex-direction:column;align-items:center;justify-content:center;
pointer-events:auto;transition:opacity .6s;z-index:100;overflow:hidden;
}
#menu::before{
content:â€™â€™;position:absolute;inset:0;
background:url(â€œdata:image/svg+xml,%3Csvg xmlns=â€˜http://www.w3.org/2000/svgâ€™ width=â€˜60â€™ height=â€˜60â€™%3E%3Ccircle cx=â€˜30â€™ cy=â€˜30â€™ r=â€˜1â€™ fill=â€˜whiteâ€™ opacity=â€™.15â€™/%3E%3C/svg%3Eâ€);
animation:starScroll 60s linear infinite;
}
@keyframes starScroll{from{background-position:0 0}to{background-position:1000px 1000px}}
.menu-stars{position:absolute;inset:0;pointer-events:none;}
.star{position:absolute;background:#fff;border-radius:50%;animation:twinkle 3s infinite;}
@keyframes twinkle{0%,100%{opacity:.2;transform:scale(1)}50%{opacity:1;transform:scale(1.5)}}

.game-title{
font-family:â€˜Baloo 2â€™,cursive; font-size:clamp(2rem,7vw,4.5rem); font-weight:800;
color:#fff; text-align:center; line-height:1; margin-bottom:6px;
filter:drop-shadow(0 0 20px rgba(255,209,102,.6));
animation:titleFloat 4s ease-in-out infinite;
}
@keyframes titleFloat{0%,100%{transform:translateY(0)}50%{transform:translateY(-8px)}}
.game-sub{color:var(â€“gold);font-size:1rem;font-weight:700;letter-spacing:.3em;text-transform:uppercase;margin-bottom:28px;opacity:.8;}

.menu-card{
background:rgba(255,255,255,.05);backdrop-filter:blur(20px);
border:1px solid rgba(255,255,255,.12);border-radius:24px;
padding:32px 28px;width:90%;max-width:440px;
box-shadow:0 25px 60px rgba(0,0,0,.5),inset 0 1px 0 rgba(255,255,255,.1);
}
.field-group{margin-bottom:14px;text-align:left;}
.field-label{color:rgba(255,255,255,.6);font-size:.78rem;font-weight:700;letter-spacing:.1em;text-transform:uppercase;margin-bottom:5px;display:block;}
.field-input{
width:100%;padding:12px 16px;background:rgba(255,255,255,.08);
border:1.5px solid rgba(255,255,255,.15);border-radius:12px;
color:#fff;font-family:â€˜Nunitoâ€™,sans-serif;font-size:1rem;outline:none;
transition:border-color .2s;
}
.field-input:focus{border-color:var(â€“gold);}
.field-input::placeholder{color:rgba(255,255,255,.3);}
.color-row{display:flex;gap:10px;align-items:center;}
.color-pick{height:44px;width:80px;padding:4px;border-radius:10px;border:2px solid rgba(255,255,255,.2);background:rgba(255,255,255,.05);cursor:pointer;}
.divider{height:1px;background:rgba(255,255,255,.08);margin:18px 0;}

.btn-main{
width:100%;padding:16px;font-family:â€˜Baloo 2â€™,cursive;font-size:1.4rem;font-weight:800;
background:linear-gradient(135deg,#FFD166,#FF6B6B);color:#fff;border:none;border-radius:14px;
cursor:pointer;box-shadow:0 8px 0 rgba(0,0,0,.3),0 0 30px rgba(255,209,102,.3);
transition:transform .1s,box-shadow .1s;margin-bottom:10px;
}
.btn-main:active{transform:translateY(6px);box-shadow:0 2px 0 rgba(0,0,0,.3);}
.btn-vc{background:linear-gradient(135deg,#4ECDC4,#44a08d);}
.btn-key{background:linear-gradient(135deg,#6A0DAD,#9b59b6);}
.btn-sm{background:rgba(255,255,255,.08);border:1.5px solid rgba(255,255,255,.15);color:#fff;border-radius:10px;padding:10px 16px;font-family:â€˜Nunitoâ€™,sans-serif;font-size:.9rem;font-weight:700;cursor:pointer;transition:.2s;}
.btn-sm:hover{background:rgba(255,255,255,.15);}

#conn-status{color:var(â€“gold);font-size:.85rem;font-weight:700;text-align:center;margin-top:8px;min-height:20px;}

/* â”€â”€ KEY MODAL â”€â”€ */
#key-modal{
position:absolute;inset:0;background:rgba(0,0,0,.82);
display:none;align-items:center;justify-content:center;z-index:400;pointer-events:auto;
}
.km-inner{
background:linear-gradient(135deg,#1a1a2e,#16213e);
border:2px solid rgba(106,13,173,.6);border-radius:24px;
padding:36px 32px;text-align:center;width:90%;max-width:360px;
box-shadow:0 0 60px rgba(106,13,173,.4);
}
.km-title{font-family:â€˜Baloo 2â€™,cursive;font-size:1.8rem;color:var(â€“gold);margin-bottom:8px;}
.km-sub{color:rgba(255,255,255,.5);font-size:.85rem;margin-bottom:20px;}
#key-input{
font-size:2.4rem;letter-spacing:.6rem;padding:14px;border-radius:14px;
border:2px solid rgba(106,13,173,.5);width:100%;text-align:center;
font-family:â€˜Baloo 2â€™,cursive;background:rgba(0,0,0,.4);color:#fff;
margin-bottom:16px;outline:none;
}
#key-input:focus{border-color:var(â€“gold);}
#key-status{font-size:.9rem;font-weight:700;min-height:22px;margin-top:10px;}
.km-btns{display:flex;gap:10px;justify-content:center;}

/* â”€â”€ HUD â”€â”€ */
#hud{position:absolute;top:0;left:0;display:none;pointer-events:auto;}
.hud-panel{
background:rgba(10,10,26,.75);backdrop-filter:blur(12px);
border:1px solid rgba(255,255,255,.1);border-radius:0 0 16px 0;
padding:12px 16px;min-width:180px;
}
.hud-room{color:var(â€“blue);font-weight:700;font-size:.85rem;margin-bottom:4px;}
.hud-time{color:#fff;font-size:1.1rem;font-weight:900;font-family:â€˜Baloo 2â€™,cursive;margin-bottom:8px;}
.hud-mode{background:linear-gradient(90deg,#6A0DAD,#9b59b6);color:#fff;font-size:.75rem;font-weight:700;padding:3px 10px;border-radius:20px;display:inline-block;margin-bottom:8px;}
.counts{display:grid;grid-template-columns:1fr 1fr;gap:3px;}
.cnt{font-size:.82rem;font-weight:700;color:#ddd;}
.cnt-tiny{color:var(â€“gold)!important;font-weight:900;}

/* â”€â”€ TOP RIGHT â”€â”€ */
#top-right{position:absolute;top:12px;right:12px;display:flex;gap:8px;align-items:center;pointer-events:auto;}
.map-sel{
background:rgba(10,10,26,.85);border:1.5px solid rgba(255,255,255,.2);
color:#fff;font-family:â€˜Nunitoâ€™,sans-serif;font-size:.9rem;font-weight:700;
padding:8px 12px;border-radius:10px;cursor:pointer;outline:none;backdrop-filter:blur(10px);
}
.icon-btn{
width:38px;height:38px;border-radius:10px;border:1.5px solid rgba(255,255,255,.2);
background:rgba(10,10,26,.85);color:#fff;font-size:1rem;cursor:pointer;
display:flex;align-items:center;justify-content:center;backdrop-filter:blur(10px);
pointer-events:auto;
}

/* â”€â”€ DEV PANEL â”€â”€ */
#dev-btns{
position:absolute;bottom:175px;right:14px;display:none;flex-direction:column;gap:6px;pointer-events:auto;z-index:160;
}
.dev-mbtn{
background:rgba(0,40,0,.9);border:1.5px solid #00ff00;color:#00ff00;
font-family:monospace;font-size:.78rem;font-weight:bold;padding:8px 12px;
border-radius:8px;cursor:pointer;text-align:left;white-space:nowrap;
}
.dev-mbtn:active{background:rgba(0,100,0,.9);}
#dev-panel{
position:absolute;top:0;left:50%;transform:translateX(-50%);
background:rgba(0,20,0,.9);border:1.5px solid #00FF00;border-radius:0 0 12px 12px;
color:#00FF00;font-family:monospace;font-size:.68rem;padding:8px 14px;
display:none;pointer-events:none;line-height:1.8;white-space:pre;z-index:150;
}

/* â”€â”€ FLOATING NAMES â”€â”€ */
.fname{
position:absolute;color:#fff;background:rgba(0,0,0,.7);
padding:2px 10px;border-radius:20px;font-size:12px;font-weight:700;
transform:translate(-50%,-100%);pointer-events:none;display:none;
text-shadow:0 1px 2px #000;border:1px solid rgba(255,255,255,.2);
white-space:nowrap;
}
.fname-dev  {background:rgba(0,160,0,.85)!important;}
.fname-admin{background:rgba(140,0,210,.85)!important;}

/* â”€â”€ DIALOGUE â”€â”€ */
#dialogue{
position:absolute;bottom:24px;left:50%;transform:translateX(-50%);
width:92%;max-width:640px;background:rgba(10,10,26,.95);
border:2px solid rgba(78,205,196,.4);border-radius:20px;padding:18px;
display:none;box-shadow:0 10px 40px rgba(0,0,0,.6),0 0 20px rgba(78,205,196,.15);
align-items:center;gap:16px;z-index:102;pointer-events:auto;
}
.d-img{width:72px;height:72px;border-radius:14px;border:2px solid var(â€“blue);object-fit:cover;flex-shrink:0;}
.d-text{font-size:1rem;color:#e0e0e0;line-height:1.5;flex-grow:1;}
.d-name{color:var(â€“blue);font-weight:900;font-size:1.1rem;}
.d-btn{background:linear-gradient(135deg,var(â€“blue),#44a08d);color:#fff;border:none;padding:10px 20px;border-radius:10px;cursor:pointer;font-family:â€˜Baloo 2â€™,cursive;font-size:1rem;font-weight:700;white-space:nowrap;}

/* â”€â”€ BANNERS â”€â”€ */
#unlock-banner{
position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
background:rgba(255,209,102,.97);border:4px solid #FF8C00;border-radius:24px;
padding:24px 36px;font-size:1.4rem;font-weight:900;color:#333;
display:none;z-index:200;text-align:center;pointer-events:none;
box-shadow:0 0 60px rgba(255,209,102,.5);animation:bannerPop .3s cubic-bezier(.34,1.56,.64,1);
}
@keyframes bannerPop{from{transform:translate(-50%,-50%) scale(.5)}to{transform:translate(-50%,-50%) scale(1)}}
#unlock-banner img{width:80px;height:80px;border-radius:12px;display:block;margin:10px auto;object-fit:cover;}
#locked-msg{
position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
background:rgba(10,10,26,.95);border:3px solid #FF4444;border-radius:20px;
padding:22px 30px;font-size:1.15rem;font-weight:700;color:#fff;
display:none;z-index:200;text-align:center;pointer-events:none;
}
#toast{
position:absolute;top:75px;left:50%;transform:translateX(-50%);
background:rgba(10,10,26,.92);color:#fff;border:1px solid rgba(255,255,255,.15);
border-radius:12px;padding:10px 22px;font-size:.92rem;font-weight:700;
display:none;z-index:250;pointer-events:none;white-space:nowrap;
backdrop-filter:blur(10px);
}

/* â”€â”€ SKIN SELECTOR â”€â”€ */
.sk-min{
position:absolute;top:-28px;right:0;background:rgba(10,10,26,.88);border:1px solid rgba(255,255,255,.15);
color:rgba(255,255,255,.7);border-radius:8px 8px 0 0;padding:3px 10px;font-size:.75rem;
cursor:pointer;pointer-events:auto;font-family:â€˜Nunitoâ€™,sans-serif;font-weight:700;
}
#skin-sel{
position:absolute;top:60px;right:12px;
z-index:103;pointer-events:auto;
background:rgba(10,10,26,.88);backdrop-filter:blur(12px);
border:1px solid rgba(255,255,255,.12);border-radius:16px;padding:8px 10px;
gap:5px;align-items:flex-start;flex-wrap:wrap;justify-content:flex-end;
display:none;max-width:160px;flex-direction:column;
}
.sk-lbl{color:rgba(255,255,255,.6);font-weight:700;font-size:.75rem;letter-spacing:.08em;text-transform:uppercase;width:100%;text-align:center;margin-bottom:4px;}
.sk-btn{
padding:7px 14px;font-size:.82rem;font-weight:700;
background:rgba(255,255,255,.1);border:1.5px solid rgba(255,255,255,.2);
color:#fff;border-radius:8px;cursor:pointer;font-family:â€˜Nunitoâ€™,sans-serif;
transition:.15s;
}
.sk-btn:hover{background:rgba(255,255,255,.2);}
.sk-btn.sk-active{background:var(â€“gold);color:#333;border-color:var(â€“gold);}
.sk-btn.sk-dev  {background:rgba(0,160,0,.6);border-color:#00aa00;}
.sk-btn.sk-admin{background:rgba(140,0,210,.6);border-color:#8b00cc;}

/* â”€â”€ MOBILE JOYSTICK â”€â”€ */
#joy-wrap{position:absolute;bottom:28px;left:28px;display:none;pointer-events:auto;}
#joy-outer{
width:130px;height:130px;background:rgba(255,255,255,.1);
border:3px solid rgba(255,255,255,.3);border-radius:50%;
position:relative;touch-action:none;
}
#joy-inner{
width:58px;height:58px;background:rgba(255,255,255,.75);border-radius:50%;
position:absolute;top:36px;left:36px;
box-shadow:0 4px 12px rgba(0,0,0,.3);transition:none;pointer-events:none;
}
#jump-btn{
position:absolute;bottom:40px;right:40px;width:82px;height:82px;
background:rgba(255,209,102,.25);border:3px solid rgba(255,209,102,.7);
border-radius:50%;pointer-events:auto;display:none;
color:#fff;font-weight:900;font-size:1rem;font-family:â€˜Baloo 2â€™,cursive;
text-shadow:0 1px 3px #000;
}

/* â”€â”€ CAM HINT â”€â”€ */
#cam-hint{
position:absolute;bottom:14px;right:14px;
background:rgba(10,10,26,.82);backdrop-filter:blur(8px);
border:1px solid rgba(255,255,255,.1);color:rgba(255,255,255,.8);
border-radius:12px;padding:10px 14px;font-size:.75rem;line-height:1.7;
display:none;pointer-events:none;
}

/* â”€â”€ PLAYER SPRITE CHOOSER (multiplayer) â”€â”€ */
#sprite-row{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-bottom:6px;}
.sprite-opt{
width:48px;height:48px;border-radius:10px;border:2.5px solid rgba(255,255,255,.2);
cursor:pointer;object-fit:cover;background:#222;transition:.15s;
}
.sprite-opt.chosen{border-color:var(â€“gold);box-shadow:0 0 12px rgba(255,209,102,.5);}
</style>

</head>
<body>
<div id="ui">

<!-- MAIN MENU -->

<div id="menu">
  <div class="menu-stars" id="menu-stars"></div>
  <div class="game-title">Find Tiny's<br>Family</div>
  <div class="game-sub">A turtle's search across the world</div>
  <div class="menu-card">
    <!-- Sprite picker -->
    <div class="field-group">
      <span class="field-label">Choose your character</span>
      <div id="sprite-row"></div>
    </div>
    <div class="field-group">
      <span class="field-label">Your name</span>
      <input class="field-input" id="inp-name" placeholder="Enter your name..." maxlength="14">
    </div>
    <div class="divider"></div>
    <div class="field-group">
      <span class="field-label">Join code (blank = host)</span>
      <input class="field-input" id="inp-room" placeholder="Leave blank to host a game" maxlength="12">
    </div>
    <button class="btn-main" onclick="startGame()">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="white" style="vertical-align:middle;margin-right:6px"><polygon points="5,3 19,12 5,21"/></svg>
      Enter World
    </button>
    <button class="btn-main btn-vc" id="vc-btn" onclick="enableVC()">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" style="vertical-align:middle;margin-right:6px"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
      Enable Voice Chat
    </button>
    <button class="btn-main btn-key" onclick="openKey()">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" style="vertical-align:middle;margin-right:6px"><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"/></svg>
      Enter Access Key
    </button>
    <div id="conn-status">Ready to connect</div>
  </div>
</div>

<!-- KEY MODAL -->

<div id="key-modal">
  <div class="km-inner">
    <div class="km-title">ğŸ”‘ Access Key</div>
    <div class="km-sub">Enter your 6-digit key</div>
    <input type="password" id="key-input" maxlength="6" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢" inputmode="numeric" autocomplete="off">
    <div class="km-btns">
      <button class="btn-main" style="width:auto;padding:10px 24px;font-size:1rem;" onclick="submitKey()">Submit</button>
      <button class="btn-sm" onclick="closeKey()">Cancel</button>
    </div>
    <div id="key-status"></div>
  </div>
</div>

<!-- HUD -->

<div id="hud">
  <div class="hud-panel">
    <div class="hud-room" id="room-tag">Connecting...</div>
    <div class="hud-time" id="timer-tag">00:00</div>
    <div id="mode-tag" class="hud-mode" style="display:none">Mode</div>
    <div class="counts">
      <div class="cnt" id="c-dad">Dad 0/1</div>
      <div class="cnt" id="c-mum">Mum 0/1</div>
      <div class="cnt" id="c-bro">Bros 0/8</div>
      <div class="cnt" id="c-sis">Sis 0/9</div>
      <div class="cnt cnt-tiny" id="c-tiny">Tiny 0/1</div>
      <div class="cnt" id="c-map">Map 1</div>
    </div>
  </div>
</div>

<div id="top-right">
  <button class="icon-btn" id="mic-btn" onclick="toggleMic()" style="display:none" title="Toggle Mic">
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/></svg>
  </button>
  <select class="map-sel" id="map-sel" onchange="tryMap(this.value)">
    <option value="1">ğŸ  Map 1 â€” Neighborhood</option>
    <option value="2">ğŸ¢ Map 2 â€” Turtle Beach</option>
    <option value="3">ğŸ”’ Map 3 â€” Tiny's Hideout</option>
  </select>
</div>

<div id="dev-panel"></div>

<div id="peer-labels"></div>
<div id="name-label" class="fname">Player</div>

<!-- DIALOGUE -->

<div id="dialogue">
  <img class="d-img" id="d-img" src="friend.png"
    onerror="this.onerror=null;this.style.visibility='hidden';"
    alt="Friend">
  <div class="d-text">
    <div class="d-name">Friend ğŸ¢</div>
    "Tiny and the whole family have gone missing! They're scattered everywhere â€” some are hiding in sneaky spots. Beach is next, and Tiny has a secret classroom hideout. Can you find them all?"
  </div>
  <button class="d-btn" onclick="document.getElementById('dialogue').style.display='none'">
    Let's Go!
  </button>
</div>

<!-- SKIN SELECTOR -->

<div id="skin-sel"><span class="sk-lbl">Skin</span></div>

<!-- BANNERS -->

<div id="unlock-banner"></div>
<div id="locked-msg"></div>
<div id="toast"></div>

<!-- CAM HINT -->

<div id="cam-hint">
  <b>Camera</b><br>
  â† â†’ â†‘ â†“ Arrow keys<br>
  Mouse drag Â· Scroll zoom<br>
  Right-side touch drag
</div>

<!-- MOBILE -->

<!-- DEV MOBILE BUTTONS -->

<div id="dev-btns">
  <button class="dev-mbtn" onclick="flyMode=!flyMode;showToast(flyMode?'Fly ON':'Fly OFF')">âœˆ Fly toggle</button>
  <button class="dev-mbtn" onclick="player.position.set(0,20,0);showToast('Reset')">âŒ‚ Reset pos</button>
  <button class="dev-mbtn" onclick="adminCollect()">â˜… Collect all</button>
  <button class="dev-mbtn" onclick="camDist=Math.max(4,camDist-5)">+ Zoom in</button>
  <button class="dev-mbtn" onclick="camDist=Math.min(80,camDist+5)">- Zoom out</button>
</div>
<div id="joy-wrap"><div id="joy-outer"><div id="joy-inner"></div></div></div>
<button id="jump-btn">JUMP</button>
</div>

<script>
'use strict';
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONSTANTS & STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SPRITES = ['friend','dad','mum','tiny','brother','sister','admin','dev'];
const SPRITE_FALLBACK_COLORS = {
  friend:'#4ECDC4',dad:'#3498db',mum:'#e91e8c',tiny:'#FFD166',
  brother:'#2980b9',sister:'#e91e63',admin:'#9b59b6',dev:'#27ae60'
};

// Skin groups: finding all of a type unlocks that skin
const SKIN_GROUPS = {dad:'dad',mum:'mum',brother:'brother',sister:'sister',tiny:'tiny'};
// These are special and only unlocked by keys
const KEY_ONLY_SKINS = ['dev','admin'];
// 'friend' is always unlocked (the default skin)
const ALWAYS_UNLOCKED = ['friend'];

let playerName='Player', chosenSprite='friend', accessMode='normal';
let currentMap=1, secondsElapsed=0, timerInterval=null, gameStarted=false;
let flyMode=false, flyVelY=0, velocityY=0, isGrounded=false;

let famTargets = {dad:1,mum:1,brother:8,sister:9,tiny:1};
let famFound   = {dad:0,mum:0,brother:0,sister:0,tiny:0};
let groupUnlocked = {};

// â”€â”€ PERSISTENT UNLOCK STORAGE â”€â”€
// Only 'friend' is available by default. Everything else must be earned.
function loadUnlocked(){
  try{
    const saved=JSON.parse(localStorage.getItem('ftf_unlocked')||'[]');
    // Always include 'friend', merge saved
    const base=[...ALWAYS_UNLOCKED];
    saved.forEach(s=>{ if(!base.includes(s)) base.push(s); });
    return base;
  } catch(e){ return [...ALWAYS_UNLOCKED]; }
}
function saveUnlocked(){
  try{ localStorage.setItem('ftf_unlocked',JSON.stringify(unlockedSkins)); } catch(e){}
}

let unlockedSkins = loadUnlocked();
let currentSkin = unlockedSkins[0]; // friend by default

let familyMeshes=[], obstacles=[], grassBlades=[], cloudMeshes=[];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MENU â€” animated stars
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
(function buildMenuStars(){
  const c=document.getElementById('menu-stars');
  for(let i=0;i<80;i++){
    const s=document.createElement('div');
    s.className='star';
    const sz=Math.random()*2+1;
    s.style.cssText=`width:${sz}px;height:${sz}px;top:${Math.random()*100}%;left:${Math.random()*100}%;animation-delay:${Math.random()*4}s;animation-duration:${2+Math.random()*3}s;`;
    c.appendChild(s);
  }
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SPRITE PICKER â€” locked sprites shown greyed with padlock
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildSpritePicker(){
  const row=document.getElementById('sprite-row');
  row.innerHTML='';
  SPRITES.forEach(name=>{
    const isUnlocked=unlockedSkins.includes(name);
    const wrap=document.createElement('div');
    wrap.style.cssText='position:relative;display:inline-block;';

    const img=document.createElement('img');
    img.className='sprite-opt';
    img.src=name+'.png';
    img.title=isUnlocked ? name[0].toUpperCase()+name.slice(1) : 'ğŸ”’ Locked';
    img.dataset.name=name;
    if(!isUnlocked){ img.style.filter='grayscale(1) brightness(.4)'; img.style.cursor='not-allowed'; }

    img.onerror=function(){
      const cv=document.createElement('canvas'); cv.width=cv.height=48;
      const ctx=cv.getContext('2d');
      // No initials/text â€” just a colored circle placeholder
      ctx.fillStyle=isUnlocked?(SPRITE_FALLBACK_COLORS[name]||'#555'):'#222';
      ctx.beginPath(); ctx.arc(24,24,22,0,Math.PI*2); ctx.fill();
      if(!isUnlocked){
        // draw lock symbol
        ctx.fillStyle='#888'; ctx.fillRect(18,22,12,10); ctx.beginPath();
        ctx.arc(24,22,5,Math.PI,0); ctx.strokeStyle='#888'; ctx.lineWidth=2; ctx.stroke();
      }
      img.src=cv.toDataURL();
    };

    if(isUnlocked){
      img.onclick=()=>{
        document.querySelectorAll('.sprite-opt').forEach(x=>x.classList.remove('chosen'));
        img.classList.add('chosen'); chosenSprite=name;
        localStorage.setItem('ftf_lastSprite',name);
      };
    } else {
      // Show lock icon overlay
      const lock=document.createElement('div');
      lock.textContent='ğŸ”’';
      lock.style.cssText='position:absolute;top:0;right:0;font-size:14px;pointer-events:none;';
      wrap.appendChild(lock);
    }

    wrap.appendChild(img);
    row.appendChild(wrap);
  });

  // Restore last chosen sprite if still unlocked, else default to friend
  const last=localStorage.getItem('ftf_lastSprite');
  const defaultChoice=last&&unlockedSkins.includes(last)?last:'friend';
  chosenSprite=defaultChoice;
  const target=row.querySelector(`img[data-name="${defaultChoice}"]`);
  if(target) target.classList.add('chosen');
}
buildSpritePicker();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ACCESS KEY SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const KEYS={'212121':'dev','221122':'admin'};
function openKey(){ document.getElementById('key-modal').style.display='flex'; setTimeout(()=>document.getElementById('key-input').focus(),120); }
function closeKey(){ document.getElementById('key-modal').style.display='none'; }
document.getElementById('key-input').addEventListener('keydown',e=>{ if(e.key==='Enter')submitKey(); if(e.key==='Escape')closeKey(); });

function submitKey(){
  const v=document.getElementById('key-input').value.trim();
  const ks=document.getElementById('key-status');
  const mode=KEYS[v];
  if(mode){
    accessMode=mode;
    ks.style.color='#00FF88';
    if(mode==='dev'){
      ks.textContent='âœ” Dev Mode unlocked!';
      // Dev only gets dev skin (not family skins â€” those must be earned)
      giveExtraSkins(['dev']);
    } else {
      ks.textContent='âœ” Admin Mode unlocked!';
      // Admin gets dev + admin skins. Family skins still must be earned in-game.
      // (adminCollect will auto-collect family, triggering group unlocks properly)
      giveExtraSkins(['dev','admin']);
    }
    if(gameStarted){ buildSkinSel(); updateModeTag(); if(mode==='admin') adminCollect(); }
    setTimeout(closeKey,1800);
  } else {
    ks.style.color='#FF4444'; ks.textContent='âœ˜ Wrong key.';
    document.getElementById('key-input').value='';
    document.getElementById('key-input').focus();
  }
}
function giveExtraSkins(arr){ let changed=false; arr.forEach(s=>{ if(!unlockedSkins.includes(s)){ unlockedSkins.push(s); changed=true; } }); if(changed){ saveUnlocked(); buildSpritePicker(); } }
function updateModeTag(){
  const mt=document.getElementById('mode-tag');
  if(accessMode==='dev')  { mt.textContent='ğŸ›  Dev Mode';   mt.style.display='inline-block'; document.getElementById('dev-panel').style.display='block'; document.getElementById('dev-btns').style.display='flex'; }
  if(accessMode==='admin'){ mt.textContent='ğŸ‘‘ Admin Mode'; mt.style.display='inline-block'; }
}
function adminCollect(){
  for(let i=familyMeshes.length-1;i>=0;i--){
    const f=familyMeshes[i]; scene.remove(f.mesh);
    famFound[f.type]++; checkGroupUnlock(f.type); familyMeshes.splice(i,1);
  }
  updateHUD(); showToast('ğŸ‘‘ All family collected!');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  VOICE CHAT (up to 10 players)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let peer, peers={}, localStream=null, micEnabled=false;

async function enableVC(){
  const btn=document.getElementById('vc-btn'); btn.disabled=true; btn.textContent='Requesting mic...';
  try{
    localStream=await navigator.mediaDevices.getUserMedia({audio:true});
    localStream.getAudioTracks()[0].enabled=false;
    btn.textContent='âœ” Voice Chat Ready'; btn.style.background='linear-gradient(135deg,#27ae60,#2ecc71)';
    document.getElementById('mic-btn').style.display='flex';
    showToast('Voice chat ready â€” tap mic to unmute');
  } catch(e){
    btn.disabled=false; btn.textContent='Enable Voice Chat';
    showToast('Mic denied: '+e.message);
  }
}
function toggleMic(){
  if(!localStream) return;
  micEnabled=!micEnabled;
  localStream.getAudioTracks()[0].enabled=micEnabled;
  const btn=document.getElementById('mic-btn');
  btn.style.background=micEnabled?'rgba(39,174,96,.8)':'rgba(10,10,26,.85)';
}

function initNet(code){
  const tag=document.getElementById('room-tag');
  const st=document.getElementById('conn-status');
  try{
    const myId=code?null:Math.random().toString(36).substr(2,6).toUpperCase();
    peer=new Peer(myId);
    peer.on('open',id=>{
      if(code){ tag.textContent='Lobby: '+code; connectTo(code); }
      else { tag.textContent='Host: '+id; st.innerHTML=`Code: <b style="font-size:1.2rem">${id}</b>`; }
    });
    peer.on('error',e=>{ tag.textContent='Net error'; console.warn(e.type); });
    peer.on('connection',conn=>handleConn(conn));
    peer.on('call',call=>{ if(localStream) call.answer(localStream); call.on('stream',s=>playStream(s)); });
  } catch(e){ tag.textContent='Offline'; }
}
function connectTo(id){
  if(Object.keys(peers).length>=10){ showToast('Max 10 players'); return; }
  const conn=peer.connect(id); handleConn(conn);
  if(localStream){ const c=peer.call(id,localStream); c.on('stream',s=>playStream(s)); }
}
function handleConn(conn){
  conn.on('open',()=>conn.send({type:'init',name:playerName,sprite:chosenSprite}));
  conn.on('data',data=>{
    if(!peers[conn.peer]) makePeerMesh(conn.peer);
    const p=peers[conn.peer];
    if(data.type==='init'){ loadSpriteFor(p.mesh,data.sprite); p.labelDiv.innerText=data.name; p.conn=conn; }
    else if(data.type==='move'){ p.mesh.position.set(data.x,data.y,data.z); p.mesh.lookAt(camera.position.x,data.y,camera.position.z); }
  });
  conn.on('close',()=>{ if(peers[conn.peer]){ scene.remove(peers[conn.peer].mesh); peers[conn.peer].labelDiv.remove(); delete peers[conn.peer]; } });
}
function makePeerMesh(id){
  const mesh=new THREE.Mesh(new THREE.PlaneGeometry(2,2.2),new THREE.MeshStandardMaterial({color:0xffffff,side:THREE.DoubleSide,transparent:true}));
  mesh.castShadow=true; scene.add(mesh);
  const lbl=document.createElement('div'); lbl.className='fname'; lbl.style.display='block'; lbl.innerText='Player';
  document.getElementById('peer-labels').appendChild(lbl);
  peers[id]={mesh,labelDiv:lbl,conn:null};
}
function loadSpriteFor(mesh,spriteName){
  tLoader.load(spriteName+'.png',tex=>{ mesh.material.map=tex; mesh.material.color.set(0xFFFFFF); mesh.material.needsUpdate=true; },null,()=>{ mesh.material.color.set(SPRITE_FALLBACK_COLORS[spriteName]||'#fff'); });
}
function playStream(stream){ const a=document.createElement('audio'); a.srcObject=stream; a.autoplay=true; a.style.display='none'; document.body.appendChild(a); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  THREE.JS CORE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(68,innerWidth/innerHeight,.1,1200);
const renderer=new THREE.WebGLRenderer({antialias:true,powerPreference:'high-performance'});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.shadowMap.enabled=true;
renderer.shadowMap.type=THREE.PCFSoftShadowMap;
renderer.toneMapping=THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure=1.35;
document.body.insertBefore(renderer.domElement,document.getElementById('ui'));

const tLoader=new THREE.TextureLoader();

// â”€â”€ LIGHTING â”€â”€
const hemiLight=new THREE.HemisphereLight(0xffe5a0,0x3a7010,1.2);
scene.add(hemiLight);

const sun=new THREE.DirectionalLight(0xffdd55,2.6);
sun.castShadow=true;
sun.shadow.mapSize.width=sun.shadow.mapSize.height=4096;  // Extended shadow map
sun.shadow.camera.near=1; sun.shadow.camera.far=800;
sun.shadow.camera.left=-250; sun.shadow.camera.right=250;
sun.shadow.camera.top=250;   sun.shadow.camera.bottom=-250;
sun.shadow.bias=-0.0005;
sun.shadow.normalBias=0.02;
scene.add(sun);

// Secondary fill light from opposite side
const fillLight=new THREE.DirectionalLight(0x4488ff,.35);
fillLight.position.set(-1,.5,-1);
scene.add(fillLight);

const ambient=new THREE.AmbientLight(0xffd0a0,.25);
scene.add(ambient);

// Day/night cycle â€” starts at dawn (~6am feel)
let dayT=Math.PI*0.08;  // dawn
const DAY_SPEED=0.00012; // full cycle ~14 min

scene.fog=new THREE.FogExp2(0xffeaa0,.0018); // exponential for richer atmosphere
scene.background=new THREE.Color(0xffc87a);

// â”€â”€ TERRAIN â”€â”€
const terrainMats={
  1:new THREE.MeshStandardMaterial({color:0x4a8c28,roughness:.9,metalness:0}),
  2:new THREE.MeshStandardMaterial({color:0xf0d090,roughness:.85,metalness:0}),
  3:new THREE.MeshStandardMaterial({color:0xd4c4a0,roughness:.7,metalness:0})
};
tLoader.load('grass.png',tex=>{ tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.repeat.set(80,80); terrainMats[1].map=tex; terrainMats[1].needsUpdate=true; },null,()=>{});

let terrain=null;
function buildTerrain(m){
  if(terrain){ scene.remove(terrain); terrain.geometry.dispose(); terrain=null; }
  const size = m===3 ? 160 : 800;
  const segs = m===3 ? 8   : 128;
  const geo=new THREE.PlaneGeometry(size,size,segs,segs);
  geo.rotateX(-Math.PI/2);
  if(m!==3){
    const pos=geo.attributes.position;
    for(let i=0;i<pos.count;i++){
      const x=pos.getX(i),z=pos.getZ(i);
      // Layered hills: large rolling + medium bumps + small noise
      let y = Math.sin(x*0.012)*Math.cos(z*0.012)*18
            + Math.sin(x*0.03 +1)*Math.cos(z*0.025+2)*8
            + Math.sin(x*0.07 )*Math.cos(z*0.08 )*3;
      if(m===2) y=0; // beach is flat sand
      pos.setY(i,y);
    }
    geo.computeVertexNormals();
  }
  terrain=new THREE.Mesh(geo,terrainMats[m]);
  terrain.receiveShadow=true; scene.add(terrain);
}

// â”€â”€ PLAYER â”€â”€
const playerGeo=new THREE.PlaneGeometry(2.4,2.7);
const playerMat=new THREE.MeshStandardMaterial({color:0x4ECDC4,side:THREE.DoubleSide,transparent:true,alphaTest:.05});
const player=new THREE.Mesh(playerGeo,playerMat);
player.castShadow=true; scene.add(player);

const disc=new THREE.Mesh(new THREE.CircleGeometry(.9,16),new THREE.MeshBasicMaterial({color:0,transparent:true,opacity:.22}));
disc.rotation.x=-Math.PI/2; scene.add(disc);

// â”€â”€ CLOUDS â”€â”€
function buildClouds(){
  cloudMeshes.forEach(c=>scene.remove(c)); cloudMeshes=[];
  if(currentMap===3) return; // indoor classroom â€” no clouds
  const cloudMat=new THREE.MeshStandardMaterial({color:0xffffff,transparent:true,opacity:.82,roughness:1,depthWrite:false});
  for(let i=0;i<22;i++){
    const g=new THREE.Group();
    // Flatter, wider clouds â€” scale y down so they look like proper cumulus
    const w=Math.random()*60+40, baseR=Math.random()*5+5;
    for(let j=0;j<6;j++){
      const r=baseR*(0.6+Math.random()*0.7);
      const sphere=new THREE.Mesh(new THREE.SphereGeometry(r,7,5),cloudMat);
      sphere.scale.y=0.45+Math.random()*0.2; // flatten each puff
      sphere.position.set((Math.random()-.5)*w,(Math.random()-.3)*baseR*.5,(Math.random()-.5)*20);
      g.add(sphere);
    }
    const spread=500;
    // Height 140-200 â€” well above terrain and camera
    g.position.set((Math.random()-.5)*spread, 140+Math.random()*60, (Math.random()-.5)*spread);
    g.userData.speed=Math.random()*.008+.003;
    g.userData.dir=Math.random()>.5?1:-1;
    scene.add(g); cloudMeshes.push(g);
  }
}

// â”€â”€ RAYCASTER â”€â”€
const gRay=new THREE.Raycaster();
const dVec=new THREE.Vector3(0,-1,0);
function terrainH(x,z){
  if(!terrain) return 0;
  gRay.set(new THREE.Vector3(x,500,z),dVec);
  const h=gRay.intersectObject(terrain);
  return h.length?h[0].point.y:0;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CAMERA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let camYaw=0, camPitch=.42, camDist=22, camDistTarget=22;
const housePositions=[]; // filled by addHouse
const CAM_SPD=.03;

let mDrag=false,lmx=0,lmy=0;
renderer.domElement.addEventListener('mousedown',e=>{ if(e.button===0){mDrag=true;lmx=e.clientX;lmy=e.clientY;} });
renderer.domElement.addEventListener('mousemove',e=>{ if(!mDrag) return; camYaw-=(e.clientX-lmx)*.004; camPitch-=(e.clientY-lmy)*.004; camPitch=clamp(camPitch,.05,1.45); lmx=e.clientX;lmy=e.clientY; });
renderer.domElement.addEventListener('mouseup',()=>mDrag=false);
renderer.domElement.addEventListener('mouseleave',()=>mDrag=false);
renderer.domElement.addEventListener('wheel',e=>{ camDistTarget=clamp((camDistTarget||camDist)+e.deltaY*.06,4,80); },{passive:true});

const camt={};
renderer.domElement.addEventListener('touchstart',e=>{ for(const t of e.changedTouches) if(t.clientX>innerWidth*.45) camt[t.identifier]={x:t.clientX,y:t.clientY}; },{passive:true});
renderer.domElement.addEventListener('touchmove',e=>{ for(const t of e.changedTouches){ if(camt[t.identifier]){ const p=camt[t.identifier]; camYaw-=(t.clientX-p.x)*.005; camPitch-=(t.clientY-p.y)*.005; camPitch=clamp(camPitch,.05,1.45); camt[t.identifier]={x:t.clientX,y:t.clientY}; e.preventDefault(); } } },{passive:false});
renderer.domElement.addEventListener('touchend',e=>{ for(const t of e.changedTouches) delete camt[t.identifier]; },{passive:true});

function doUpdateCamera(){
  // House proximity zoom â€” smoothly pull camera in when near a house
  if(currentMap===1 && housePositions.length){
    let nearest=9999;
    for(const h of housePositions){
      const dx=player.position.x-h.x, dz=player.position.z-h.z;
      const inside=Math.abs(dx)<h.w*.55&&Math.abs(dz)<h.d*.55;
      const dist=Math.sqrt(dx*dx+dz*dz);
      nearest=Math.min(nearest,inside?0:dist);
    }
    // Inside house â†’ pull to 10; near entrance (<8) â†’ 14; else 22
    if(nearest===0) camDistTarget=10;
    else if(nearest<8) camDistTarget=14;
    else camDistTarget=22;
  } else {
    camDistTarget=currentMap===3?12:22;
  }
  camDist+=(camDistTarget-camDist)*.08; // smooth lerp
  camera.position.set(
    player.position.x+Math.sin(camYaw)*camDist*Math.cos(camPitch),
    player.position.y+Math.sin(camPitch)*camDist,
    player.position.z+Math.cos(camYaw)*camDist*Math.cos(camPitch)
  );
  camera.lookAt(player.position.x,player.position.y+1.2,player.position.z);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SKINS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SKIN_IMGS={friend:'friend.png',dad:'dad.png',mum:'mum.png',brother:'brother.png',sister:'sister.png',tiny:'tiny.png',admin:'admin.png',dev:'dev.png'};
const skinCache={};
function loadSkinTex(name,cb){
  if(name in skinCache){cb(skinCache[name]);return;}
  if(!SKIN_IMGS[name]){skinCache[name]=null;cb(null);return;}
  tLoader.load(SKIN_IMGS[name],t=>{skinCache[name]=t;cb(t);},null,()=>{skinCache[name]=null;cb(null);});
}
function applySkin(name){
  currentSkin=name;
  loadSkinTex(name,tex=>{
    playerMat.map=tex||null;
    playerMat.color.set(tex?0xFFFFFF:SPRITE_FALLBACK_COLORS[name]||0x4ECDC4);
    playerMat.needsUpdate=true;
  });
  document.querySelectorAll('.sk-btn').forEach(b=>b.classList.toggle('sk-active',b.dataset.s===name));
  // Keep dialogue portrait in sync with current skin
  const dImg=document.getElementById('d-img');
  if(dImg){
    dImg.src=name+'.png';
    dImg.onerror=function(){ this.onerror=null; this.style.visibility='hidden'; this.style.background=SPRITE_FALLBACK_COLORS[name]||'#4ECDC4'; };
  }
  const dName=document.querySelector('#dialogue .d-name');
  if(dName) dName.textContent=(name[0].toUpperCase()+name.slice(1))+' ğŸ¢';
}
let skinSelCollapsed=false;
function buildSkinSel(){
  const sel=document.getElementById('skin-sel');
  // Minimise button
  let minBtn=sel.querySelector('.sk-min');
  if(!minBtn){
    minBtn=document.createElement('button'); minBtn.className='sk-min';
    minBtn.textContent=skinSelCollapsed?'â–² Skin':'â–¼';
    minBtn.onclick=e=>{ e.stopPropagation(); skinSelCollapsed=!skinSelCollapsed; buildSkinSel(); };
    sel.appendChild(minBtn);
  }
  // Rebuild content
  sel.innerHTML='';
  // Re-add minimise button
  const mb=document.createElement('button'); mb.className='sk-min';
  mb.textContent=skinSelCollapsed?'â–² Skin':'â–¼ Hide';
  mb.onclick=e=>{ e.stopPropagation(); skinSelCollapsed=!skinSelCollapsed; buildSkinSel(); };
  sel.appendChild(mb);
  if(!skinSelCollapsed){
    const lbl=document.createElement('span'); lbl.className='sk-lbl'; lbl.textContent='Skin'; sel.appendChild(lbl);
    unlockedSkins.forEach(s=>{
      const b=document.createElement('button'); b.className='sk-btn'; b.dataset.s=s;
      b.textContent=s==='dev'?'Dev':s==='admin'?'Admin':s[0].toUpperCase()+s.slice(1);
      if(s==='dev') b.classList.add('sk-dev');
      if(s==='admin') b.classList.add('sk-admin');
      if(s===currentSkin) b.classList.add('sk-active');
      b.onclick=()=>applySkin(s); sel.appendChild(b);
    });
  }
  sel.style.display = unlockedSkins.length > 1 ? 'flex' : 'none';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FAMILY SPAWN â€” Map 1: 9, Map 2: 10, Map 3: Tiny only
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Distribution across maps:
// Map1: dad, mum, 4 brothers, 4 sisters  = 10 (but tiny not here) = 9 non-tiny + 0
// Map2: 4 brothers, 5 sisters = 10 (beach) â€” tortoises on dry sand
// Map3: tiny only

const MAP_ROSTER = {
  1:[{type:'dad',s:2.4},{type:'mum',s:2.2},{type:'brother',s:1.9},{type:'brother',s:1.9},{type:'brother',s:1.9},{type:'brother',s:1.9},{type:'sister',s:1.7},{type:'sister',s:1.7},{type:'sister',s:1.7}],
  2:[{type:'brother',s:1.9},{type:'brother',s:1.9},{type:'brother',s:1.9},{type:'brother',s:1.9},{type:'sister',s:1.7},{type:'sister',s:1.7},{type:'sister',s:1.7},{type:'sister',s:1.7},{type:'sister',s:1.7},{type:'sister',s:1.7}],
  3:[{type:'tiny',s:1.0}]
};

// Hard hiding spots for map 1 â€” behind/under things
const HARD_SPOTS_MAP1 = [
  // Inside houses (same coords as houseData entries)
  [30,0,30],    // inside house 1
  [80,0,-20],   // inside house 2
  [-60,0,50],   // inside house 3
  [50,0,-80],   // inside house 4
  [-90,0,-30],  // inside house 5
  // Behind hills / far edges
  [160,0,100],
  [-170,0,-60],
  [0,0,180],
  [-150,0,150]
];

function spawnFamily(){
  const roster=MAP_ROSTER[currentMap]||[];
  roster.forEach((mem,idx)=>{
    const mat=new THREE.MeshStandardMaterial({side:THREE.DoubleSide,transparent:true,alphaTest:.05});
    tLoader.load(mem.type+'.png',tex=>{mat.map=tex;mat.color.set(0xFFFFFF);mat.needsUpdate=true;},null,()=>mat.color.set(typeCol(mem.type)));
    const mesh=new THREE.Mesh(new THREE.PlaneGeometry(mem.s,mem.s*1.3),mat);
    let mx,mz;
    if(currentMap===3){
      // Tiny hides specifically â€” behind teacher desk or in corner by bookshelf
      const tinySpots=[[-48,28],[48,25],[-48,-28],[0,-32],[30,25]];
      const spot=tinySpots[Math.floor(Math.random()*tinySpots.length)];
      mx=spot[0]+(Math.random()-.5)*4; mz=spot[1]+(Math.random()-.5)*4;
    }
    else if(currentMap===1 && HARD_SPOTS_MAP1[idx]){
      // Place near hard spots with small random offset
      const hs=HARD_SPOTS_MAP1[idx];
      mx=hs[0]+(Math.random()-.5)*12; mz=hs[2]+(Math.random()-.5)*12;
    } else if(currentMap===2){
      // Beach: dry sand only (not in ocean zone). Keep inside z -150..150, x -300..300
      mx=(Math.random()-.5)*500; mz=(Math.random()-.5)*250;
      // Keep away from ocean edge
      if(mz<-130) mz=-130+Math.random()*30;
    } else {
      mx=(Math.random()-.5)*500; mz=(Math.random()-.5)*500;
    }
    const ty=terrainH(mx,mz);
    mesh.position.set(mx,ty+mem.s*.6,mz);
    mesh.castShadow=true; scene.add(mesh);
    familyMeshes.push({mesh,type:mem.type});
  });
}

function typeCol(t){ return {dad:0x3498db,mum:0xe91e8c,brother:0x2980b9,sister:0xe91e63,tiny:0xFFD166}[t]||0xffffff; }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MAP BUILDERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function mkMesh(geo,params){ return new THREE.Mesh(geo,new THREE.MeshStandardMaterial(params)); }

function clearScene(){
  famFound={dad:0,mum:0,brother:0,sister:0,tiny:0};
  groupUnlocked={};
  familyMeshes.forEach(f=>scene.remove(f.mesh));
  obstacles.forEach(o=>scene.remove(o.mesh||o));
  grassBlades.forEach(g=>scene.remove(g));
  scene.children.filter(c=>c.userData.deco).forEach(c=>scene.remove(c));
  familyMeshes=[]; obstacles=[]; grassBlades=[]; housePositions.length=0;
}

function loadMap(m){
  clearScene(); buildTerrain(m); setLighting(m); buildClouds();
  if(m===1) buildNeighborhood();
  else if(m===2) buildBeach();
  else buildClassroom();
  player.position.set(0,20,0); flyVelY=0; velocityY=0; isGrounded=false;
  document.getElementById('c-map').textContent='Map '+m;
  updateHUD();
  if(accessMode==='admin') setTimeout(adminCollect,400);
}

// â”€â”€ LIGHTING PER MAP â”€â”€
function setLighting(m){
  if(m===1){
    hemiLight.color.set(0xffeaa0); hemiLight.groundColor.set(0x4a7a20); hemiLight.intensity=1.0;
    ambient.color.set(0xffd0a0); ambient.intensity=.25;
    scene.fog.color.set(0xffcc88); scene.fog.density=.0016;
  } else if(m===2){
    hemiLight.color.set(0xaaddff); hemiLight.groundColor.set(0xf0d090); hemiLight.intensity=1.2;
    ambient.color.set(0xbbeeff); ambient.intensity=.3;
    scene.fog.color.set(0xaaccee); scene.fog.density=.0012;
  } else {
    hemiLight.color.set(0xffeedd); hemiLight.groundColor.set(0x997755); hemiLight.intensity=.7;
    ambient.color.set(0xffddbf); ambient.intensity=.45;
    scene.fog.color.set(0xeeddcc); scene.fog.density=.008;
  }
}

// â”€â”€ MAP 1: NEIGHBORHOOD â”€â”€
function buildNeighborhood(){
  // Houses
  const houseData=[
    [30,0,30],[80,0,-20],[-60,0,50],[50,0,-80],[-90,0,-30],[110,0,70],[-40,0,-120],[0,0,110],[130,0,-100],
    [-120,0,80],[70,0,150],[-150,0,-80],[20,0,-160],[160,0,20],[-80,0,160]
  ];
  houseData.forEach(([x,,z])=>{ const ty=terrainH(x,z); addHouse(x,ty,z); });

  // Trees â€” lots!
  for(let i=0;i<120;i++) addTree((Math.random()-.5)*700,(Math.random()-.5)*700);

  // Big rocks
  for(let i=0;i<80;i++){
    const s=Math.random()*4+1.5;
    const rx=(Math.random()-.5)*700,rz=(Math.random()-.5)*700;
    const rock=mkMesh(new THREE.DodecahedronGeometry(s,1),{color:0x666666,roughness:.95});
    rock.position.set(rx,terrainH(rx,rz)+s/2,rz); rock.castShadow=rock.receiveShadow=true; rock.userData.deco=true; scene.add(rock);
    obstacles.push({mesh:rock,radius:s*1.2,x:rx,z:rz});
  }

  // Fences
  for(let i=0;i<30;i++){
    const fx=(Math.random()-.5)*600,fz=(Math.random()-.5)*600;
    for(let j=0;j<6;j++){
      const post=mkMesh(new THREE.BoxGeometry(.4,3,.4),{color:0xd4a87a,roughness:.9});
      post.position.set(fx+j*3,terrainH(fx+j*3,fz)+1.5,fz); post.castShadow=true; post.userData.deco=true; scene.add(post);
    }
    const rail=mkMesh(new THREE.BoxGeometry(18,.3,.3),{color:0xc49060,roughness:.9});
    rail.position.set(fx+7.5,terrainH(fx,fz)+2.5,fz); rail.userData.deco=true; scene.add(rail);
  }

  // Tall grass patches
  spawnGrass(600,700);
  spawnFamily();
}

function addHouse(x,ty,z){
  const w=14+Math.random()*10, d=12+Math.random()*8, h=7+Math.random()*4;
  const cols=[0xF5E6C8,0xDCE8E8,0xF9D5A7,0xE8D5C8,0xCCDDCC];
  const roofCols=[0xC0392B,0x7B3B2E,0x2C5F8A,0x4A4A4A,0x8B4513];
  const col=cols[Math.floor(Math.random()*cols.length)];
  const rcol=roofCols[Math.floor(Math.random()*roofCols.length)];
  const wm=new THREE.MeshStandardMaterial({color:col,roughness:.9});
  const doorW=3, doorH=4;

  // Build walls as separate panels so there is a real door gap in the front
  // Front wall: two side panels (left & right of door) + top strip
  const frontSideW=(w-doorW)/2;
  // Front left panel
  const fl=new THREE.Mesh(new THREE.BoxGeometry(frontSideW,h,.3),wm);
  fl.position.set(x-doorW/2-frontSideW/2,ty+h/2,z+d/2); fl.castShadow=fl.receiveShadow=true; fl.userData.deco=true; scene.add(fl);
  // Front right panel
  const fr=new THREE.Mesh(new THREE.BoxGeometry(frontSideW,h,.3),wm);
  fr.position.set(x+doorW/2+frontSideW/2,ty+h/2,z+d/2); fr.castShadow=fr.receiveShadow=true; fr.userData.deco=true; scene.add(fr);
  // Front top strip above door
  const ft=new THREE.Mesh(new THREE.BoxGeometry(w,h-doorH,.3),wm);
  ft.position.set(x,ty+doorH+(h-doorH)/2,z+d/2); ft.castShadow=true; ft.userData.deco=true; scene.add(ft);
  // Back wall
  const bk=new THREE.Mesh(new THREE.BoxGeometry(w,h,.3),wm);
  bk.position.set(x,ty+h/2,z-d/2); bk.castShadow=bk.receiveShadow=true; bk.userData.deco=true; scene.add(bk);
  // Left wall
  const lw=new THREE.Mesh(new THREE.BoxGeometry(.3,h,d),wm);
  lw.position.set(x-w/2,ty+h/2,z); lw.castShadow=lw.receiveShadow=true; lw.userData.deco=true; scene.add(lw);
  // Right wall
  const rw=new THREE.Mesh(new THREE.BoxGeometry(.3,h,d),wm);
  rw.position.set(x+w/2,ty+h/2,z); rw.castShadow=rw.receiveShadow=true; rw.userData.deco=true; scene.add(rw);

  // Roof
  const roof=mkMesh(new THREE.ConeGeometry(Math.max(w,d)*.78,h*.65,4),{color:rcol,roughness:.9});
  roof.position.set(x,ty+h+h*.32,z); roof.rotation.y=Math.PI/4; roof.castShadow=true; roof.userData.deco=true; scene.add(roof);

  // Thick floor slab â€” extends 6 units below ground so hill cutaway is never visible
  const floorSlab=mkMesh(new THREE.BoxGeometry(w+.4,8,d+.4),{color:0xc8a87a,roughness:.85});
  floorSlab.position.set(x,ty-3.5,z); floorSlab.receiveShadow=true; floorSlab.userData.deco=true; scene.add(floorSlab);

  // Windows â€” 2 on front sides, 1 each on left/right/back walls, all matched to wall height
  const winH=h*.45, winY=ty+h*.6;
  const winMat=new THREE.MeshStandardMaterial({color:0xaaddff,roughness:.05,metalness:.1,transparent:true,opacity:.65});
  const winFrame=new THREE.MeshStandardMaterial({color:0xffffff,roughness:.8});
  function addWindow(wx,wy,wz,wo,ww2,wh2,rotY){
    // Frame sits proud of wall; glass recessed inside frame â€” no z-fighting
    const frame=new THREE.Mesh(new THREE.BoxGeometry(ww2+.5,wh2+.5,.35),winFrame);
    frame.rotation.y=rotY; frame.position.set(wx,wy,wz); frame.userData.deco=true; scene.add(frame);
    const glass=new THREE.Mesh(new THREE.BoxGeometry(ww2-.1,wh2-.1,.12),winMat);
    glass.rotation.y=rotY; glass.position.set(wx,wy,wz); glass.userData.deco=true; scene.add(glass);
  }
  // Front windows (each side of door)
  addWindow(x-w/4,winY,z+d/2+.05,0,2.2,winH,0);
  addWindow(x+w/4,winY,z+d/2+.05,0,2.2,winH,0);
  // Back windows
  addWindow(x-w/4,winY,z-d/2-.05,0,2.2,winH,0);
  addWindow(x+w/4,winY,z-d/2-.05,0,2.2,winH,0);
  // Side windows
  addWindow(x+w/2+.05,winY,z-d/4,0,2.2,winH,Math.PI/2);
  addWindow(x+w/2+.05,winY,z+d/4,0,2.2,winH,Math.PI/2);
  addWindow(x-w/2-.05,winY,z-d/4,0,2.2,winH,Math.PI/2);
  addWindow(x-w/2-.05,winY,z+d/4,0,2.2,winH,Math.PI/2);

  // Door frame
  const dfm=new THREE.MeshStandardMaterial({color:0x5c3010,roughness:.9});
  const df=new THREE.Mesh(new THREE.BoxGeometry(doorW+.4,.2,d*.01+.4),dfm);
  df.position.set(x,ty+doorH,z+d/2); df.userData.deco=true; scene.add(df);

  // Interior: bed + wardrobe for hiding spots
  const bedMat=new THREE.MeshStandardMaterial({color:0x6688aa,roughness:.8});
  const bed=new THREE.Mesh(new THREE.BoxGeometry(4,1,6),bedMat);
  bed.position.set(x+w*.25,ty+.5,z-d*.2); bed.castShadow=true; bed.userData.deco=true; scene.add(bed);
  // Wardrobe
  const ward=mkMesh(new THREE.BoxGeometry(3,h*.7,2),{color:0x8B6535,roughness:.9});
  ward.position.set(x-w*.3,ty+h*.35,z+d*.25); ward.castShadow=ward.receiveShadow=true; ward.userData.deco=true; scene.add(ward);

  // Collision: only the 4 wall CORNERS block (thin walls = radius just the corner posts)
  // Left and right outer walls block
  obstacles.push({mesh:lw,radius:.8,x:x-w/2,z});
  obstacles.push({mesh:rw,radius:.8,x:x+w/2,z});
  // Back wall blocks
  obstacles.push({mesh:bk,radius:.8,x,z:z-d/2});
  // Wardrobe blocks
  obstacles.push({mesh:ward,radius:2,x:x-w*.3,z:z+d*.25});
  // Record centre for camera zoom
  housePositions.push({x,z,w,d});
}

function addTree(x,z){
  const ty=terrainH(x,z);
  const trunk=mkMesh(new THREE.CylinderGeometry(.35,.6,5+Math.random()*3,7),{color:0x6b3d1e,roughness:1});
  trunk.position.set(x,ty+3,z); trunk.castShadow=true; trunk.userData.deco=true; scene.add(trunk);
  const cr=3+Math.random()*3;
  const crown=mkMesh(new THREE.SphereGeometry(cr,8,6),{color:0x2d7a20+(Math.floor(Math.random()*4)*0x050000),roughness:1});
  crown.position.set(x,ty+5+cr*.6,z); crown.castShadow=true; crown.userData.deco=true; scene.add(crown);
  obstacles.push({mesh:trunk,radius:1.4,x,z});
}

// â”€â”€ MAP 2: TURTLE BEACH â”€â”€
function buildBeach(){
  // Single ocean plane â€” sits clearly below sand level, no layering
  const ocean=mkMesh(new THREE.PlaneGeometry(3000,1200),{color:0x0d7ab5,roughness:.08,metalness:.2});
  ocean.rotation.x=-Math.PI/2; ocean.position.set(0,-3,0); ocean.userData.deco=true; scene.add(ocean);

  // Wet sand fringe where water meets beach â€” just a thin darker strip, same plane level as terrain
  const wet=mkMesh(new THREE.PlaneGeometry(3000,60),{color:0xd4a84a,roughness:.9});
  wet.rotation.x=-Math.PI/2; wet.position.set(0,0.01,-170); wet.userData.deco=true; scene.add(wet);

  // Ocean only visible south of z=-180 â€” block player from swimming
  // (beach terrain flat, water below it â€” clean edge)

  // Palm trees on dry sand
  for(let i=0;i<70;i++){
    const px=(Math.random()-.5)*700, pz=(Math.random()-.5)*200;
    addPalm(px,pz);
  }

  // Tall grass tufts on beach
  spawnBeachGrass(200,600,180);

  // Beach umbrellas and towels
  for(let i=0;i<20;i++) addUmbrella((Math.random()-.5)*500,(Math.random()-.5)*200);

  // Rocks/tide pools â€” keep on dry sand
  for(let i=0;i<50;i++){
    const s=Math.random()*3+.8;
    const rx=(Math.random()-.5)*600, rz=(Math.random()-.5)*220;
    const rock=mkMesh(new THREE.SphereGeometry(s,5,4),{color:0xB0A090,roughness:.95});
    rock.position.set(rx,terrainH(rx,rz)+s*.4,rz); rock.castShadow=true; rock.userData.deco=true; scene.add(rock);
    obstacles.push({mesh:rock,radius:s*1.2,x:rx,z:rz});
  }

  // Sand dunes
  for(let i=0;i<20;i++){
    const dx=(Math.random()-.5)*600, dz=(Math.random()-.5)*220;
    const dune=mkMesh(new THREE.SphereGeometry(8+Math.random()*14,8,6),{color:0xe8c870,roughness:1});
    dune.scale.y=.22; dune.position.set(dx,.2,dz); dune.receiveShadow=true; dune.userData.deco=true; scene.add(dune);
  }

  // Turtle shells (decorative)
  for(let i=0;i<14;i++){
    const sx=(Math.random()-.5)*500, sz=(Math.random()-.5)*200;
    addShell(sx,sz);
  }

  spawnFamily();
}

function spawnBeachGrass(count,spreadX,spreadZ){
  // Beach grass â€” yellowish sea grass tufts
  const gm=new THREE.MeshStandardMaterial({color:0xc8c040,side:THREE.DoubleSide,transparent:true,alphaTest:.08,roughness:1});
  for(let i=0;i<count;i++){
    const gx=(Math.random()-.5)*spreadX, gz=(Math.random()-.5)*spreadZ;
    const g=new THREE.Mesh(new THREE.PlaneGeometry(1.2+Math.random()*.8,2+Math.random()*1.5),gm);
    g.position.set(gx,terrainH(gx,gz)+1+Math.random()*.5,gz);
    g.rotation.y=Math.random()*Math.PI;
    scene.add(g); grassBlades.push(g);
  }
}

function addPalm(x,z){
  const ty=terrainH(x,z);
  const trunk=mkMesh(new THREE.CylinderGeometry(.25,.5,8+Math.random()*4,6),{color:0x9b7845,roughness:1});
  trunk.position.set(x,ty+5,z); trunk.rotation.z=(Math.random()-.5)*.3; trunk.castShadow=true; trunk.userData.deco=true; scene.add(trunk);
  const top=mkMesh(new THREE.SphereGeometry(3.5,8,5),{color:0x2ea020+(Math.floor(Math.random()*3)*0x030000),roughness:1});
  top.scale.y=.3; top.position.set(x+Math.sin(trunk.rotation.z)*8,ty+10,z); top.userData.deco=true; scene.add(top);
  obstacles.push({mesh:trunk,radius:1.2,x,z});
}

function addUmbrella(x,z){
  const ty=terrainH(x,z);
  const pole=mkMesh(new THREE.CylinderGeometry(.08,.08,4,5),{color:0xaaaaaa});
  pole.position.set(x,ty+2,z); pole.userData.deco=true; scene.add(pole);
  const cols=[0xff4444,0xffcc00,0x44aaff,0xff8800,0xff44ff,0x44ff88];
  const canopy=mkMesh(new THREE.ConeGeometry(3.2,1.2,8),{color:cols[Math.floor(Math.random()*cols.length)]});
  canopy.rotation.x=Math.PI; canopy.position.set(x,ty+4.2,z); canopy.userData.deco=true; scene.add(canopy);
  // Towel
  const towel=mkMesh(new THREE.BoxGeometry(3.5,.05,5),{color:cols[Math.floor(Math.random()*cols.length)],roughness:.9});
  towel.position.set(x+(Math.random()-.5)*4,ty+.06,z+(Math.random()-.5)*4); towel.userData.deco=true; scene.add(towel);
}

function addShell(x,z){
  const ty=terrainH(x,z);
  const shell=mkMesh(new THREE.SphereGeometry(1.2,6,5),{color:0x8B6914,roughness:.9});
  shell.scale.y=.55; shell.position.set(x,ty+.5,z); shell.userData.deco=true; scene.add(shell);
}

// â”€â”€ MAP 3: CLASSROOM â”€â”€
function buildClassroom(){
  const W=120,D=80,H=10;
  const wm=new THREE.MeshStandardMaterial({color:0xf5f0e8,roughness:.9});

  // Walls with collision
  const wallDefs=[[0,H/2,-D/2,W,H,.5],[0,H/2,D/2,W,H,.5],[-W/2,H/2,0,.5,H,D],[W/2,H/2,0,.5,H,D]];
  wallDefs.forEach(([wx,wy,wz,ww,wh,wd])=>{
    const m=new THREE.Mesh(new THREE.BoxGeometry(ww,wh,wd),wm); m.position.set(wx,wy,wz); m.castShadow=m.receiveShadow=true; m.userData.deco=true; scene.add(m);
    // Collision: use the longer dimension as radius along correct axis
    const colR=Math.max(ww,wd)*.5+.8;
    // For front/back walls (z offset), block in z; for side walls (x offset), block in x
    // We push per-wall segment obstacles
    if(Math.abs(wz)>10){ // front or back wall
      for(let seg=-W/2+4;seg<W/2;seg+=8) obstacles.push({mesh:m,radius:1.5,x:wx+seg,z:wz});
    } else { // side walls
      for(let seg=-D/2+4;seg<D/2;seg+=8) obstacles.push({mesh:m,radius:1.5,x:wx,z:wz+seg});
    }
  });
  // Ceiling
  const ceil=mkMesh(new THREE.PlaneGeometry(W,D),{color:0xeeeeee}); ceil.rotation.x=Math.PI/2; ceil.position.y=H; ceil.userData.deco=true; scene.add(ceil);
  // Classroom tiled floor â€” raised above terrain so no z-fighting
  const floorMat=new THREE.MeshStandardMaterial({color:0xd8c8a8,roughness:.6});
  const classFloor=new THREE.Mesh(new THREE.PlaneGeometry(W-.6,D-.6),floorMat);
  classFloor.rotation.x=-Math.PI/2; classFloor.position.set(0,.15,0); classFloor.receiveShadow=true; classFloor.userData.deco=true; scene.add(classFloor);

  // Blackboard
  const board=mkMesh(new THREE.BoxGeometry(40,8,.4),{color:0x1a5c2a,roughness:.8}); board.position.set(0,6,-D/2+.5); board.castShadow=true; board.userData.deco=true; scene.add(board);
  // Math equations on board (white lines)
  const eqns=['2+2=4','Ï€=3.14','âˆ‘nÂ²','âˆš64=8'];
  eqns.forEach((eq,i)=>{
    const line=mkMesh(new THREE.BoxGeometry(8,.4,.1),{color:0xffffff,emissive:0xffffff,emissiveIntensity:.3});
    line.position.set(-14+i*9,6.5,-D/2+.7); line.userData.deco=true; scene.add(line);
  });

  // Desks (rows of 5 x 4)
  for(let row=0;row<4;row++){
    for(let col=0;col<5;col++){
      const dx=-35+col*17, dz=-20+row*12;
      addDesk(dx,dz);
    }
  }
  // Teacher desk
  addDesk(0,-35,true);

  // Bookshelves
  [-55,55].forEach(sx=>{
    const shelf=mkMesh(new THREE.BoxGeometry(4,8,D*.7),{color:0x8B6535,roughness:.9}); shelf.position.set(sx,4,5); shelf.castShadow=shelf.receiveShadow=true; shelf.userData.deco=true; scene.add(shelf);
    obstacles.push({mesh:shelf,radius:4,x:sx,z:5});
    // Books on shelf
    for(let b=0;b<20;b++){
      const bookCols=[0xcc2222,0x2255cc,0x22aa44,0xcc8822,0x884499,0x226688,0xaa3355,0x558833];
      const bk=mkMesh(new THREE.BoxGeometry(.4,1.5,.8),{color:bookCols[b%bookCols.length],roughness:.9}); bk.position.set(sx+1.6,b*.4+1,-25+b*2.5); bk.userData.deco=true; scene.add(bk);
    }
  });

  // Ceiling lights
  for(let i=0;i<4;i++){
    const bx=-30+i*20;
    const bulb=mkMesh(new THREE.SphereGeometry(.4,6,4),{color:0xffffc8,emissive:0xffffaa,emissiveIntensity:1.5});
    bulb.position.set(bx,H-.5,0); bulb.userData.deco=true; scene.add(bulb);
    const pl=new THREE.PointLight(0xffeebb,2,35); pl.position.set(bx,H-1,0); pl.userData.deco=true; scene.add(pl);
  }

  // Globe on teacher desk area
  const globe=mkMesh(new THREE.SphereGeometry(2,12,8),{color:0x4488ff,roughness:.4,metalness:.2});
  globe.position.set(12,4,-33); globe.userData.deco=true; scene.add(globe);
  const stand=mkMesh(new THREE.CylinderGeometry(.15,.15,2.5,6),{color:0x888888});
  stand.position.set(12,2.75,-33); stand.userData.deco=true; scene.add(stand);
  const standBase=mkMesh(new THREE.CylinderGeometry(.6,.8,.3,8),{color:0x666666});
  standBase.position.set(12,1.5,-33); standBase.userData.deco=true; scene.add(standBase);

  // Windows with daylight
  [[W/2,5,0],[W/2,5,20],[W/2,5,-20]].forEach(([x,y,z])=>{
    const win=mkMesh(new THREE.BoxGeometry(.4,5,8),{color:0xaaddff,transparent:true,opacity:.65,roughness:.05}); win.position.set(x,y,z); win.userData.deco=true; scene.add(win);
  });

  spawnFamily();
}

function addDesk(x,z,big=false){
  const s=big?1.6:1;
  const desk=mkMesh(new THREE.BoxGeometry(7*s,.25,4*s),{color:0xc8a060,roughness:.8}); desk.position.set(x,1.6,z); desk.castShadow=desk.receiveShadow=true; desk.userData.deco=true; scene.add(desk);
  [[-2.8,-.8],[2.8,-.8],[-2.8,1.5],[2.8,1.5]].forEach(([ox,oz])=>{
    const leg=mkMesh(new THREE.CylinderGeometry(.15,.15,1.6,4),{color:0x7a5020}); leg.position.set(x+ox*s,1,z+oz*s); leg.userData.deco=true; scene.add(leg);
  });
  // Paper on desk
  if(!big){ const paper=mkMesh(new THREE.BoxGeometry(2,.03,2.5),{color:0xfafafa,roughness:.9}); paper.position.set(x,1.76,z); paper.userData.deco=true; scene.add(paper); }
  obstacles.push({mesh:desk,radius:big?5.5:3.2,x,z});
}

function spawnGrass(count,spread){
  const gm=new THREE.MeshStandardMaterial({color:0x2a8a22,side:THREE.DoubleSide,transparent:true,alphaTest:.1});
  for(let i=0;i<count;i++){
    const g=new THREE.Mesh(new THREE.PlaneGeometry(1.5+Math.random(),3+Math.random()*2),gm);
    const gx=(Math.random()-.5)*spread,gz=(Math.random()-.5)*spread;
    g.position.set(gx,terrainH(gx,gz)+1.5+Math.random(),gz); g.rotation.y=Math.random()*Math.PI;
    scene.add(g); grassBlades.push(g);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONTROLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const moveK={w:false,a:false,s:false,d:false};
const camK={ArrowLeft:false,ArrowRight:false,ArrowUp:false,ArrowDown:false};

window.addEventListener('keydown',e=>{
  const k=e.key;
  if(k in moveK) moveK[k]=true;
  if(k in camK){ camK[k]=true; e.preventDefault(); }
  if(k===' ') doJump();
  if((k==='f'||k==='F')&&accessMode==='dev'){ flyMode=!flyMode; showToast(flyMode?'Fly ON â€” jump=rise':'Fly OFF'); }
  if((k==='r'||k==='R')&&accessMode==='dev'){ player.position.set(0,20,0); showToast('Position reset'); }
  if((k==='g'||k==='G')&&accessMode!=='normal') adminCollect();
});
window.addEventListener('keyup',e=>{ const k=e.key; if(k in moveK)moveK[k]=false; if(k in camK)camK[k]=false; });

// Joystick â€” direction relative to camera
let joyX=0,joyY=0,joyActive=false,joyC={x:0,y:0};
const GRAVITY=.024,JUMP_V=.55,SPEED=.38;

const joyOuter=document.getElementById('joy-outer');
const joyInner=document.getElementById('joy-inner');
joyOuter.addEventListener('touchstart',e=>{ joyActive=true; const r=joyOuter.getBoundingClientRect(); joyC={x:r.left+65,y:r.top+65}; joyMove(e.touches[0]); },{passive:true});
joyOuter.addEventListener('touchmove',e=>{ if(joyActive){e.preventDefault();joyMove(e.touches[0]);} },{passive:false});
joyOuter.addEventListener('touchend',()=>{ joyActive=false; joyX=joyY=0; joyInner.style.transform='translate(0,0)'; });
function joyMove(t){
  let dx=t.clientX-joyC.x,dy=t.clientY-joyC.y;
  const d=Math.sqrt(dx*dx+dy*dy),m=42;
  if(d>m){dx=dx/d*m;dy=dy/d*m;}
  joyInner.style.transform=`translate(${dx}px,${dy}px)`;
  joyX=dx/m; joyY=dy/m;
}
document.getElementById('jump-btn').addEventListener('touchstart',e=>{e.preventDefault();doJump();});
function doJump(){ if(flyMode){flyVelY=.6;return;} if(isGrounded){velocityY=JUMP_V;isGrounded=false;} }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HUD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateHUD(){
  document.getElementById('c-dad').textContent=`Dad ${famFound.dad}/${famTargets.dad}`;
  document.getElementById('c-mum').textContent=`Mum ${famFound.mum}/${famTargets.mum}`;
  document.getElementById('c-bro').textContent=`Bros ${famFound.brother}/${famTargets.brother}`;
  document.getElementById('c-sis').textContent=`Sis ${famFound.sister}/${famTargets.sister}`;
  document.getElementById('c-tiny').textContent=`Tiny ${famFound.tiny}/${famTargets.tiny}`;
  // Unlock map 3 label
  const nt=famFound.dad+famFound.mum+famFound.brother+famFound.sister;
  const tot=famTargets.dad+famTargets.mum+famTargets.brother+famTargets.sister;
  if(nt>=tot){ const o=document.querySelector('#map-sel option[value="3"]'); if(o&&o.textContent.includes('ğŸ”’')) o.textContent="ğŸ« Map 3 â€” Tiny's Hideout"; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  COLLECTION & UNLOCK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•







function checkGroupUnlock(type){
  if(groupUnlocked[type]) return;
  if(famFound[type]>=famTargets[type]){
    groupUnlocked[type]=true;
    if(!unlockedSkins.includes(type)){
      unlockedSkins.push(type);
      saveUnlocked();        // persist to localStorage
      buildSkinSel();        // update in-game switcher
      buildSpritePicker();   // update menu picker (unlocks sprite)
      showUnlockBanner(type);
    }
  }
}
function checkWin(){
  if(famFound.dad+famFound.mum+famFound.brother+famFound.sister+famFound.tiny>=20){
    setTimeout(()=>alert(`ğŸ‰ You found the WHOLE family!\n${document.getElementById('timer-tag').textContent}\nAmazing work!`),400);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MAP GATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function tryMap(v){
  v=parseInt(v);
  if(v===3&&accessMode==='normal'){
    const nf=famFound.dad+famFound.mum+famFound.brother+famFound.sister;
    const nt=famTargets.dad+famTargets.mum+famTargets.brother+famTargets.sister;
    if(nf<nt){ showLocked("Find all of Dad, Mum, Brothers & Sisters first!\n(Across Maps 1 & 2)\nThen Tiny's Hideout unlocks ğŸ”’"); document.getElementById('map-sel').value=currentMap; return; }
  }
  currentMap=v; loadMap(v);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let lastT=0;
function animate(ts=0){
  requestAnimationFrame(animate);
  const dt=Math.min((ts-lastT)/1000,.05); lastT=ts;

  // â”€â”€ Day/Night cycle â”€â”€
  dayT+=DAY_SPEED;
  const sinT=Math.sin(dayT), cosT=Math.cos(dayT);
  const sunH=Math.max(0,sinT); // 0 at night
  sun.position.set(cosT*300,sinT*300,80);
  sun.intensity=sunH*2.2+.05;
  // Vivid: saturated gold noon, deep orange dusk, cool night
  if(sunH>0.01) sun.color.setHSL(0.10-sunH*0.05,1.0,Math.max(0.45,0.55+sunH*0.1));
  else sun.color.setHSL(0.62,0.4,0.15);

  // Sky & fog colour â€” beautiful gradient
  const nightBlue=new THREE.Color(0x050520);
  const dawnOrange=new THREE.Color(0xff6600);
  const dayBlue=new THREE.Color(currentMap===2?0x55aaff:0x4499ee);
  let skyCol;
  if(sunH<.01){
    skyCol=nightBlue.clone().lerp(dawnOrange,Math.max(0,(sinT+.1)*5));
  } else {
    skyCol=dawnOrange.clone().lerp(dayBlue,Math.min(1,sunH*3));
  }
  scene.background=skyCol; scene.fog.color.copy(skyCol);
  // Fog denser at night/dawn
  if(currentMap!==3) scene.fog.density=Math.max(.001, .0016-sunH*.0006);

  // Ambient dims at night
  ambient.intensity=Math.max(.05,sunH*.3);
  hemiLight.intensity=Math.max(.1,sunH*1.1);
  // Moonlight at night
  fillLight.intensity=Math.max(0,.4-sunH*.5);
  fillLight.color.set(sunH<.1?0x8899ff:0x4488ff);

  // Clouds drift
  cloudMeshes.forEach(c=>{ c.position.x+=c.userData.speed*c.userData.dir; if(Math.abs(c.position.x)>600) c.userData.dir*=-1; });

  // Camera keys
  if(camK.ArrowLeft)  camYaw  +=CAM_SPD;
  if(camK.ArrowRight) camYaw  -=CAM_SPD;
  if(camK.ArrowUp)    camPitch =clamp(camPitch+CAM_SPD,.05,1.45);
  if(camK.ArrowDown)  camPitch =clamp(camPitch-CAM_SPD,.05,1.45);

  // Movement â€” camera-relative, joystick follows camera direction
  let mx=0,mz=0;
  const fwd=new THREE.Vector3(-Math.sin(camYaw),0,-Math.cos(camYaw));
  const rgt=new THREE.Vector3( Math.cos(camYaw),0,-Math.sin(camYaw));
  if(joyActive){
    // Joystick: forward = camera forward
    mx+=fwd.x*joyY*SPEED+rgt.x*joyX*SPEED;
    mz+=fwd.z*joyY*SPEED+rgt.z*joyX*SPEED;
    // Note: joyY negative = push up = move forward
    mx=-fwd.x*joyY*SPEED+rgt.x*joyX*SPEED;
    mz=-fwd.z*joyY*SPEED+rgt.z*joyX*SPEED;
  } else {
    if(moveK.w){mx+=fwd.x*SPEED;mz+=fwd.z*SPEED;}
    if(moveK.s){mx-=fwd.x*SPEED;mz-=fwd.z*SPEED;}
    if(moveK.a){mx-=rgt.x*SPEED;mz-=rgt.z*SPEED;}
    if(moveK.d){mx+=rgt.x*SPEED;mz+=rgt.z*SPEED;}
  }

  const nx=player.position.x+mx, nz=player.position.z+mz;
  let hit=false;
  if(!(accessMode==='dev'&&flyMode)){
    for(const r of obstacles){ if(r.mesh&&Math.sqrt((nx-r.x)**2+(nz-r.z)**2)<r.radius+.9){hit=true;break;} }
  }
  if(!hit){player.position.x=nx;player.position.z=nz;}

  // Physics
  const tH=terrainH(player.position.x,player.position.z);
  if(flyMode){
    flyVelY*=.9; player.position.y+=flyVelY;
    if(player.position.y<tH+1.2) player.position.y=tH+1.2;
    isGrounded=false;
  } else {
    if(!isGrounded){ player.position.y+=velocityY; velocityY-=GRAVITY; if(player.position.y<=tH+1.2){player.position.y=tH+1.2;isGrounded=true;velocityY=0;} }
    else{ player.position.y=tH+1.2; }
  }
  disc.position.set(player.position.x,tH+.04,player.position.z);

  // Billboards
  const cfx=camera.position.x,cfz=camera.position.z;
  player.lookAt(cfx,player.position.y,cfz);
  familyMeshes.forEach(f=>f.mesh.lookAt(cfx,f.mesh.position.y,cfz));
  for(const id in peers) peers[id].mesh.lookAt(cfx,peers[id].mesh.position.y,cfz);

  // Grass sway
  const t2=ts*.001;
  grassBlades.forEach((g,i)=>{ g.rotation.z=Math.sin(t2*1.4+i*.7)*.09; });

  doUpdateCamera();
  label3D(player,document.getElementById('name-label'));
  for(const id in peers) label3D(peers[id].mesh,peers[id].labelDiv);

  // Collection â€” larger range for hard maps
  const collectR=2.6;
  for(let i=familyMeshes.length-1;i>=0;i--){
    const f=familyMeshes[i];
    if(player.position.distanceTo(f.mesh.position)<collectR){
      scene.remove(f.mesh); famFound[f.type]++; familyMeshes.splice(i,1);
      updateHUD(); checkGroupUnlock(f.type); checkWin();
    }
  }

  // Net sync
  for(const id in peers){ const p=peers[id]; if(p.conn&&p.conn.open) p.conn.send({type:'move',x:player.position.x,y:player.position.y,z:player.position.z}); }

  // Dev panel
  if(accessMode==='dev'){
    const pp=player.position;
    document.getElementById('dev-panel').textContent=
      `POS(${pp.x.toFixed(0)},${pp.y.toFixed(0)},${pp.z.toFixed(0)}) CAM yaw:${(camYaw*57.3).toFixed(0)}Â° pitch:${(camPitch*57.3).toFixed(0)}Â°\n`+
      `Family left:${familyMeshes.length}  Map:${currentMap}  Fly:${flyMode?'ON':'OFF'}  Skin:${currentSkin}\n`+
      `[F]fly [R]reset [G]collect [â†â†’â†‘â†“]camera`;
  }

  renderer.render(scene,camera);
}

function label3D(mesh,el){
  const v=mesh.position.clone(); v.y+=2; v.project(camera);
  if(v.z>1){el.style.display='none';return;}
  el.style.left=`${(v.x*.5+.5)*innerWidth}px`; el.style.top=`${(v.y*-.5+.5)*innerHeight}px`; el.style.display='block';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UI HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showLocked(t){ const el=document.getElementById('locked-msg'); el.innerHTML='ğŸ”’ '+t.replace(/\n/g,'<br>'); el.style.display='block'; clearTimeout(el._t); el._t=setTimeout(()=>el.style.display='none',3500); }
function showUnlockBanner(type){
  const el=document.getElementById('unlock-banner'); const src=SKIN_IMGS[type]||'';
  el.innerHTML=`<div style="font-size:2.2rem">ğŸ‰ Group Found!</div>${src?`<img src="${src}" onerror="this.style.display='none'" style="object-fit:cover">`:''}  <div style="font-size:1.1rem">All <b>${type}s</b> found!<br><span style="font-size:.85rem;opacity:.8">New skin unlocked!</span></div>`;
  el.style.display='block'; clearTimeout(el._t); el._t=setTimeout(()=>el.style.display='none',4000);
}
function showToast(msg,dur=2800){ const el=document.getElementById('toast'); el.textContent=msg; el.style.display='block'; clearTimeout(el._t); el._t=setTimeout(()=>el.style.display='none',dur); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TIMER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startTimer(){ if(timerInterval)clearInterval(timerInterval); secondsElapsed=0; timerInterval=setInterval(()=>{ secondsElapsed++; const m=Math.floor(secondsElapsed/60).toString().padStart(2,'0'),s=(secondsElapsed%60).toString().padStart(2,'0'); document.getElementById('timer-tag').textContent=m+':'+s; },1000); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  START GAME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startGame(){
  playerName=document.getElementById('inp-name').value.trim()||'Explorer';
  const nameLabel=document.getElementById('name-label');
  nameLabel.innerText=playerName;
  if(accessMode==='admin') nameLabel.classList.add('fname-admin');
  if(accessMode==='dev')   nameLabel.classList.add('fname-dev');

  updateModeTag();
  initNet(document.getElementById('inp-room').value.trim());

  document.getElementById('menu').style.opacity='0';
  setTimeout(()=>{
    document.getElementById('menu').style.display='none';
    document.getElementById('hud').style.display='block';
    document.getElementById('top-right').style.display='flex';
    document.getElementById('name-label').style.display='block';
    document.getElementById('joy-wrap').style.display='block';
    document.getElementById('jump-btn').style.display='block';
    document.getElementById('cam-hint').style.display='block';
    document.getElementById('skin-sel').style.display='flex';
    document.getElementById('dialogue').style.display='flex';
    // Update dialogue image + name to match the player's chosen sprite
    const dImg = document.getElementById('d-img');
    dImg.src = currentSkin + '.png';
    dImg.onerror = function(){
      this.onerror=null; this.style.visibility='hidden';
      this.style.background=SPRITE_FALLBACK_COLORS[currentSkin]||'#4ECDC4';
    };
    document.querySelector('#dialogue .d-name').textContent = (currentSkin[0].toUpperCase()+currentSkin.slice(1)) + ' ğŸ¢';

    // Skin: use chosen sprite only if it is actually unlocked, else fall back to friend
    currentSkin=unlockedSkins.includes(chosenSprite)?chosenSprite:'friend';
    // Do NOT add chosen sprite to unlocked here â€” it must be earned (except friend)
    currentMap=1; loadMap(1);
    buildSkinSel(); applySkin(currentSkin);
    startTimer(); gameStarted=true; animate();

    setTimeout(()=>document.getElementById('cam-hint').style.display='none',8000);
  },600);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UTILS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function clamp(v,mn,mx){ return Math.max(mn,Math.min(mx,v)); }

window.addEventListener('resize',()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });
</script>

</body>
</html>