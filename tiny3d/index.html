<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<title>Find Tiny's Family</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&family=Baloo+2:wght@700;800&display=swap" rel="stylesheet">
<style>
:root {
  --gold:#FFD166; --blue:#4ECDC4; --red:#FF6B6B; --dark:#1a1a2e; --mid:#16213e;
}
*{box-sizing:border-box;margin:0;padding:0;}
body{overflow:hidden;background:#0a0a1a;font-family:'Nunito',sans-serif;touch-action:none;user-select:none;}
canvas{display:block;width:100vw;height:100vh;}
#ui{position:absolute;inset:0;pointer-events:none;}

/* â”€â”€ MENU â”€â”€ */
#menu{
  position:absolute;inset:0;
  background:radial-gradient(ellipse at 30% 40%,#0f3460 0%,#0a0a1a 70%);
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  pointer-events:auto;transition:opacity .6s;z-index:100;overflow:hidden;
}
#menu::before{
  content:'';position:absolute;inset:0;
  background:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='60' height='60'%3E%3Ccircle cx='30' cy='30' r='1' fill='white' opacity='.15'/%3E%3C/svg%3E");
  animation:starScroll 60s linear infinite;
}
@keyframes starScroll{from{background-position:0 0}to{background-position:1000px 1000px}}
.menu-stars{position:absolute;inset:0;pointer-events:none;}
.star{position:absolute;background:#fff;border-radius:50%;animation:twinkle 3s infinite;}
@keyframes twinkle{0%,100%{opacity:.2;transform:scale(1)}50%{opacity:1;transform:scale(1.5)}}

.game-title{
  font-family:'Baloo 2',cursive; font-size:clamp(2rem,7vw,4.5rem); font-weight:800;
  color:#fff; text-align:center; line-height:1; margin-bottom:6px;
  filter:drop-shadow(0 0 20px rgba(255,209,102,.6));
  animation:titleFloat 4s ease-in-out infinite;
}
@keyframes titleFloat{0%,100%{transform:translateY(0)}50%{transform:translateY(-8px)}}
.game-sub{color:var(--gold);font-size:1rem;font-weight:700;letter-spacing:.3em;text-transform:uppercase;margin-bottom:28px;opacity:.8;}

.menu-card{
  background:rgba(255,255,255,.05);backdrop-filter:blur(20px);
  border:1px solid rgba(255,255,255,.12);border-radius:24px;
  padding:32px 28px;width:90%;max-width:440px;
  box-shadow:0 25px 60px rgba(0,0,0,.5),inset 0 1px 0 rgba(255,255,255,.1);
}
.field-group{margin-bottom:14px;text-align:left;}
.field-label{color:rgba(255,255,255,.6);font-size:.78rem;font-weight:700;letter-spacing:.1em;text-transform:uppercase;margin-bottom:5px;display:block;}
.field-input{
  width:100%;padding:12px 16px;background:rgba(255,255,255,.08);
  border:1.5px solid rgba(255,255,255,.15);border-radius:12px;
  color:#fff;font-family:'Nunito',sans-serif;font-size:1rem;outline:none;
  transition:border-color .2s;
}
.field-input:focus{border-color:var(--gold);}
.field-input::placeholder{color:rgba(255,255,255,.3);}
.color-row{display:flex;gap:10px;align-items:center;}
.color-pick{height:44px;width:80px;padding:4px;border-radius:10px;border:2px solid rgba(255,255,255,.2);background:rgba(255,255,255,.05);cursor:pointer;}
.divider{height:1px;background:rgba(255,255,255,.08);margin:18px 0;}

.btn-main{
  width:100%;padding:16px;font-family:'Baloo 2',cursive;font-size:1.4rem;font-weight:800;
  background:linear-gradient(135deg,#FFD166,#FF6B6B);color:#fff;border:none;border-radius:14px;
  cursor:pointer;box-shadow:0 8px 0 rgba(0,0,0,.3),0 0 30px rgba(255,209,102,.3);
  transition:transform .1s,box-shadow .1s;margin-bottom:10px;
}
.btn-main:active{transform:translateY(6px);box-shadow:0 2px 0 rgba(0,0,0,.3);}
.btn-vc{background:linear-gradient(135deg,#4ECDC4,#44a08d);}
.btn-key{background:linear-gradient(135deg,#6A0DAD,#9b59b6);}
.btn-sm{background:rgba(255,255,255,.08);border:1.5px solid rgba(255,255,255,.15);color:#fff;border-radius:10px;padding:10px 16px;font-family:'Nunito',sans-serif;font-size:.9rem;font-weight:700;cursor:pointer;transition:.2s;}
.btn-sm:hover{background:rgba(255,255,255,.15);}

#conn-status{color:var(--gold);font-size:.85rem;font-weight:700;text-align:center;margin-top:8px;min-height:20px;}

/* â”€â”€ KEY MODAL â”€â”€ */
#key-modal{
  position:absolute;inset:0;background:rgba(0,0,0,.82);
  display:none;align-items:center;justify-content:center;z-index:400;pointer-events:auto;
}
.km-inner{
  background:linear-gradient(135deg,#1a1a2e,#16213e);
  border:2px solid rgba(106,13,173,.6);border-radius:24px;
  padding:36px 32px;text-align:center;width:90%;max-width:360px;
  box-shadow:0 0 60px rgba(106,13,173,.4);
}
.km-title{font-family:'Baloo 2',cursive;font-size:1.8rem;color:var(--gold);margin-bottom:8px;}
.km-sub{color:rgba(255,255,255,.5);font-size:.85rem;margin-bottom:20px;}
#key-input{
  font-size:2.4rem;letter-spacing:.6rem;padding:14px;border-radius:14px;
  border:2px solid rgba(106,13,173,.5);width:100%;text-align:center;
  font-family:'Baloo 2',cursive;background:rgba(0,0,0,.4);color:#fff;
  margin-bottom:16px;outline:none;
}
#key-input:focus{border-color:var(--gold);}
#key-status{font-size:.9rem;font-weight:700;min-height:22px;margin-top:10px;}
.km-btns{display:flex;gap:10px;justify-content:center;}

/* â”€â”€ HUD â”€â”€ */
#hud{position:absolute;top:0;left:0;display:none;pointer-events:auto;}
.hud-panel{
  background:rgba(10,10,26,.75);backdrop-filter:blur(12px);
  border:1px solid rgba(255,255,255,.1);border-radius:0 0 16px 0;
  padding:12px 16px;min-width:180px;
}
.hud-room{color:var(--blue);font-weight:700;font-size:.85rem;margin-bottom:4px;}
.hud-time{color:#fff;font-size:1.1rem;font-weight:900;font-family:'Baloo 2',cursive;margin-bottom:8px;}
.hud-mode{background:linear-gradient(90deg,#6A0DAD,#9b59b6);color:#fff;font-size:.75rem;font-weight:700;padding:3px 10px;border-radius:20px;display:inline-block;margin-bottom:8px;}
.counts{display:grid;grid-template-columns:1fr 1fr;gap:3px;}
.cnt{font-size:.82rem;font-weight:700;color:#ddd;}
.cnt-tiny{color:var(--gold)!important;font-weight:900;}

/* â”€â”€ TOP RIGHT â”€â”€ */
#top-right{position:absolute;top:12px;right:12px;display:flex;gap:8px;align-items:center;pointer-events:auto;}
.map-sel{
  background:rgba(10,10,26,.85);border:1.5px solid rgba(255,255,255,.2);
  color:#fff;font-family:'Nunito',sans-serif;font-size:.9rem;font-weight:700;
  padding:8px 12px;border-radius:10px;cursor:pointer;outline:none;backdrop-filter:blur(10px);
}
.icon-btn{
  width:38px;height:38px;border-radius:10px;border:1.5px solid rgba(255,255,255,.2);
  background:rgba(10,10,26,.85);color:#fff;font-size:1rem;cursor:pointer;
  display:flex;align-items:center;justify-content:center;backdrop-filter:blur(10px);
  pointer-events:auto;
}

/* â”€â”€ DEV PANEL â”€â”€ */
#dev-btns{
  position:absolute;bottom:175px;right:14px;display:none;flex-direction:column;gap:6px;pointer-events:auto;z-index:160;
}
.dev-mbtn{
  background:rgba(0,40,0,.9);border:1.5px solid #00ff00;color:#00ff00;
  font-family:monospace;font-size:.78rem;font-weight:bold;padding:8px 12px;
  border-radius:8px;cursor:pointer;text-align:left;white-space:nowrap;
}
.dev-mbtn:active{background:rgba(0,100,0,.9);}
#dev-panel{
  position:absolute;top:0;left:50%;transform:translateX(-50%);
  background:rgba(0,20,0,.9);border:1.5px solid #00FF00;border-radius:0 0 12px 12px;
  color:#00FF00;font-family:monospace;font-size:.68rem;padding:8px 14px;
  display:none;pointer-events:none;line-height:1.8;white-space:pre;z-index:150;
}

/* â”€â”€ FLOATING NAMES â”€â”€ */
.fname{
  position:absolute;color:#fff;background:rgba(0,0,0,.7);
  padding:2px 10px;border-radius:20px;font-size:12px;font-weight:700;
  transform:translate(-50%,-100%);pointer-events:none;display:none;
  text-shadow:0 1px 2px #000;border:1px solid rgba(255,255,255,.2);
  white-space:nowrap;
}
.fname-dev  {background:rgba(0,160,0,.85)!important;}
.fname-admin{background:rgba(140,0,210,.85)!important;}

/* â”€â”€ DIALOGUE â”€â”€ */
#dialogue{
  position:absolute;bottom:24px;left:50%;transform:translateX(-50%);
  width:92%;max-width:640px;background:rgba(10,10,26,.95);
  border:2px solid rgba(78,205,196,.4);border-radius:20px;padding:18px;
  display:none;box-shadow:0 10px 40px rgba(0,0,0,.6),0 0 20px rgba(78,205,196,.15);
  align-items:center;gap:16px;z-index:102;pointer-events:auto;
}
.d-img{width:72px;height:72px;border-radius:14px;border:2px solid var(--blue);object-fit:cover;flex-shrink:0;}
.d-text{font-size:1rem;color:#e0e0e0;line-height:1.5;flex-grow:1;}
.d-name{color:var(--blue);font-weight:900;font-size:1.1rem;}
.d-btn{background:linear-gradient(135deg,var(--blue),#44a08d);color:#fff;border:none;padding:10px 20px;border-radius:10px;cursor:pointer;font-family:'Baloo 2',cursive;font-size:1rem;font-weight:700;white-space:nowrap;}

/* â”€â”€ BANNERS â”€â”€ */
#unlock-banner{
  position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
  background:rgba(255,209,102,.97);border:4px solid #FF8C00;border-radius:24px;
  padding:24px 36px;font-size:1.4rem;font-weight:900;color:#333;
  display:none;z-index:200;text-align:center;pointer-events:none;
  box-shadow:0 0 60px rgba(255,209,102,.5);animation:bannerPop .3s cubic-bezier(.34,1.56,.64,1);
}
@keyframes bannerPop{from{transform:translate(-50%,-50%) scale(.5)}to{transform:translate(-50%,-50%) scale(1)}}
#unlock-banner img{width:80px;height:80px;border-radius:12px;display:block;margin:10px auto;object-fit:cover;}
#locked-msg{
  position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
  background:rgba(10,10,26,.95);border:3px solid #FF4444;border-radius:20px;
  padding:22px 30px;font-size:1.15rem;font-weight:700;color:#fff;
  display:none;z-index:200;text-align:center;pointer-events:none;
}
#toast{
  position:absolute;top:75px;left:50%;transform:translateX(-50%);
  background:rgba(10,10,26,.92);color:#fff;border:1px solid rgba(255,255,255,.15);
  border-radius:12px;padding:10px 22px;font-size:.92rem;font-weight:700;
  display:none;z-index:250;pointer-events:none;white-space:nowrap;
  backdrop-filter:blur(10px);
}
/* â”€â”€ PAUSE MENU â”€â”€ */
#pause-overlay{
  position:absolute;inset:0;background:rgba(5,5,20,.88);backdrop-filter:blur(16px);
  display:none;z-index:500;align-items:center;justify-content:center;flex-direction:column;gap:18px;
  pointer-events:auto;
}
#pause-overlay h2{color:#fff;font-size:2.2rem;font-family:'Baloo 2',cursive;margin:0;letter-spacing:.04em;}
.pause-btn{
  width:280px;padding:14px 0;font-size:1.1rem;font-weight:900;border:none;border-radius:14px;
  cursor:pointer;font-family:'Baloo 2',cursive;letter-spacing:.03em;transition:.15s;
}
.pause-btn:active{transform:scale(.97);}
.pause-resume{background:linear-gradient(135deg,#4ECDC4,#44a08d);color:#fff;}
.pause-battery{background:linear-gradient(135deg,#f9ca24,#f0932b);color:#1a1a1a;}
.pause-feature{background:rgba(255,255,255,.1);border:1.5px solid rgba(255,255,255,.2);color:#fff;}
.pause-quit{background:linear-gradient(135deg,#e74c3c,#c0392b);color:#fff;}
.pause-sep{width:280px;height:1px;background:rgba(255,255,255,.1);}
#battery-badge{
  position:absolute;top:58px;left:50%;transform:translateX(-50%);
  background:linear-gradient(135deg,#f9ca24,#f0932b);color:#1a1a1a;border-radius:20px;
  padding:5px 18px;font-size:.82rem;font-weight:900;display:none;z-index:110;
  pointer-events:none;letter-spacing:.05em;
  box-shadow:0 2px 8px rgba(0,0,0,.3);
}
/* â”€â”€ FEATURE REQUEST MODAL â”€â”€ */
#feature-modal{
  position:absolute;inset:0;background:rgba(5,5,20,.9);display:none;
  z-index:600;align-items:center;justify-content:center;
  pointer-events:auto;
}
#feature-box{
  background:rgba(20,20,40,.98);border:2px solid rgba(78,205,196,.4);border-radius:24px;
  padding:32px;width:92%;max-width:420px;display:flex;flex-direction:column;gap:14px;
}
#feature-box h3{color:#4ECDC4;font-family:'Baloo 2',cursive;font-size:1.5rem;margin:0;}
#feature-box p{color:rgba(255,255,255,.7);font-size:.9rem;margin:0;}
#feature-input{
  width:100%;box-sizing:border-box;background:rgba(255,255,255,.07);
  border:1.5px solid rgba(78,205,196,.3);border-radius:10px;
  color:#fff;padding:10px 14px;font-size:.95rem;font-family:'Nunito',sans-serif;resize:vertical;min-height:80px;
}
#feature-send{
  background:linear-gradient(135deg,#4ECDC4,#44a08d);color:#fff;border:none;
  border-radius:10px;padding:12px;font-size:1rem;font-weight:900;cursor:pointer;font-family:'Baloo 2',cursive;
}
#feature-close{
  background:rgba(255,255,255,.08);color:rgba(255,255,255,.6);border:1px solid rgba(255,255,255,.15);
  border-radius:10px;padding:10px;font-size:.9rem;cursor:pointer;font-family:'Baloo 2',cursive;
}

/* â”€â”€ SKIN SELECTOR â”€â”€ */
.sk-min{
  position:absolute;top:-28px;right:0;background:rgba(10,10,26,.88);border:1px solid rgba(255,255,255,.15);
  color:rgba(255,255,255,.7);border-radius:8px 8px 0 0;padding:3px 10px;font-size:.75rem;
  cursor:pointer;pointer-events:auto;font-family:'Nunito',sans-serif;font-weight:700;
}
#skin-sel{
  position:absolute;top:60px;right:12px;
  z-index:103;pointer-events:auto;
  background:rgba(10,10,26,.88);backdrop-filter:blur(12px);
  border:1px solid rgba(255,255,255,.12);border-radius:16px;padding:8px 10px;
  gap:5px;align-items:flex-start;flex-wrap:wrap;justify-content:flex-end;
  display:none;max-width:160px;flex-direction:column;
}
.sk-lbl{color:rgba(255,255,255,.6);font-weight:700;font-size:.75rem;letter-spacing:.08em;text-transform:uppercase;width:100%;text-align:center;margin-bottom:4px;}
.sk-btn{
  padding:7px 14px;font-size:.82rem;font-weight:700;
  background:rgba(255,255,255,.1);border:1.5px solid rgba(255,255,255,.2);
  color:#fff;border-radius:8px;cursor:pointer;font-family:'Nunito',sans-serif;
  transition:.15s;
}
.sk-btn:hover{background:rgba(255,255,255,.2);}
.sk-btn.sk-active{background:var(--gold);color:#333;border-color:var(--gold);}
.sk-btn.sk-dev  {background:rgba(0,160,0,.6);border-color:#00aa00;}
.sk-btn.sk-admin{background:rgba(140,0,210,.6);border-color:#8b00cc;}

/* â”€â”€ MOBILE JOYSTICK â”€â”€ */
#joy-wrap{position:absolute;bottom:28px;left:28px;display:none;pointer-events:auto;}
#joy-outer{
  width:130px;height:130px;background:rgba(255,255,255,.1);
  border:3px solid rgba(255,255,255,.3);border-radius:50%;
  position:relative;touch-action:none;
}
#joy-inner{
  width:58px;height:58px;background:rgba(255,255,255,.75);border-radius:50%;
  position:absolute;top:36px;left:36px;
  box-shadow:0 4px 12px rgba(0,0,0,.3);transition:none;pointer-events:none;
}
#jump-btn{
  position:absolute;bottom:40px;right:40px;width:82px;height:82px;
  background:rgba(255,209,102,.25);border:3px solid rgba(255,209,102,.7);
  border-radius:50%;pointer-events:auto;display:none;
  color:#fff;font-weight:900;font-size:1rem;font-family:'Baloo 2',cursive;
  text-shadow:0 1px 3px #000;
}
#crouch-btn{
  position:absolute;bottom:40px;right:134px;width:82px;height:82px;
  background:rgba(78,205,196,.2);border:3px solid rgba(78,205,196,.6);
  border-radius:50%;pointer-events:auto;display:none;
  color:#fff;font-weight:900;font-size:.85rem;font-family:'Baloo 2',cursive;
  text-shadow:0 1px 3px #000;
}

/* â”€â”€ CAM HINT â”€â”€ */
#cam-hint{
  position:absolute;bottom:14px;right:14px;
  background:rgba(10,10,26,.82);backdrop-filter:blur(8px);
  border:1px solid rgba(255,255,255,.1);color:rgba(255,255,255,.8);
  border-radius:12px;padding:10px 14px;font-size:.75rem;line-height:1.7;
  display:none;pointer-events:none;
}

/* â”€â”€ PLAYER SPRITE CHOOSER (multiplayer) â”€â”€ */
#sprite-row{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-bottom:6px;}
.sprite-opt{
  width:48px;height:48px;border-radius:10px;border:2.5px solid rgba(255,255,255,.2);
  cursor:pointer;object-fit:cover;background:#222;transition:.15s;
}
.sprite-opt.chosen{border-color:var(--gold);box-shadow:0 0 12px rgba(255,209,102,.5);}
</style>
</head>
<body>
<div id="ui">

<!-- MAIN MENU -->
<div id="menu">
  <div class="menu-stars" id="menu-stars"></div>
  <div class="game-title">Find Tiny's<br>Family</div>
  <div class="game-sub">A turtle's search across the world</div>
  <div class="menu-card">
    <!-- Sprite picker -->
    <div class="field-group">
      <span class="field-label">Choose your character</span>
      <div id="sprite-row"></div>
    </div>
    <div class="field-group">
      <span class="field-label">Your name</span>
      <input class="field-input" id="inp-name" placeholder="Enter your name..." maxlength="14">
    </div>
    <div class="divider"></div>
    <div class="field-group">
      <span class="field-label">Join code (blank = host)</span>
      <input class="field-input" id="inp-room" placeholder="Leave blank to host a game" maxlength="12">
    </div>
    <button class="btn-main" onclick="startGame()">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="white" style="vertical-align:middle;margin-right:6px"><polygon points="5,3 19,12 5,21"/></svg>
      Enter World
    </button>
    <button class="btn-main btn-vc" id="vc-btn" onclick="enableVC()">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" style="vertical-align:middle;margin-right:6px"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
      Enable Voice Chat
    </button>
    <button class="btn-main btn-key" onclick="openKey()">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" style="vertical-align:middle;margin-right:6px"><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"/></svg>
      Enter Access Key
    </button>
    <div id="conn-status">Ready to connect</div>
  </div>
</div>

<!-- KEY MODAL -->
<div id="key-modal">
  <div class="km-inner">
    <div class="km-title">ğŸ”‘ Access Key</div>
    <div class="km-sub">Enter your 6-digit key</div>
    <input type="password" id="key-input" maxlength="6" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢" inputmode="numeric" autocomplete="off">
    <div class="km-btns">
      <button class="btn-main" style="width:auto;padding:10px 24px;font-size:1rem;" onclick="submitKey()">Submit</button>
      <button class="btn-sm" onclick="closeKey()">Cancel</button>
    </div>
    <div id="key-status"></div>
  </div>
</div>

<!-- HUD -->
<div id="hud">
  <div class="hud-panel">
    <div class="hud-room" id="room-tag">Connecting...</div>
    <div class="hud-time" id="timer-tag">00:00</div>
    <div id="mode-tag" class="hud-mode" style="display:none">Mode</div>
    <div class="counts">
      <div class="cnt" id="c-dad">Dad 0/1</div>
      <div class="cnt" id="c-mum">Mum 0/1</div>
      <div class="cnt" id="c-bro">Bros 0/8</div>
      <div class="cnt" id="c-sis">Sis 0/9</div>
      <div class="cnt cnt-tiny" id="c-tiny">Tiny 0/1</div>
      <div class="cnt" id="c-map">Map 1</div>
    </div>
  </div>
</div>

<div id="top-right">
  <button class="icon-btn" id="mic-btn" onclick="toggleMic()" style="display:none" title="Toggle Mic">
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/></svg>
  </button>
  <select class="map-sel" id="map-sel" onchange="tryMap(this.value)">
    <option value="1">ğŸ  Map 1 â€” Neighborhood</option>
    <option value="2">ğŸ¢ Map 2 â€” Turtle Beach</option>
    <option value="3">ğŸ”’ Map 3 â€” Tiny's Hideout</option>
  </select>
</div>

<div id="dev-panel"></div>
<div id="battery-badge">âš¡ BATTERY SAVER</div>

<!-- PAUSE BUTTON (always visible in-game) -->
<button id="pause-btn" style="position:absolute;top:10px;left:10px;z-index:120;
  background:rgba(10,10,26,.8);border:1.5px solid rgba(255,255,255,.2);color:#fff;
  border-radius:10px;padding:7px 14px;font-size:.9rem;font-weight:700;cursor:pointer;
  display:none;pointer-events:auto;font-family:'Baloo 2',cursive;" onclick="togglePause()">â¸ Pause</button>

<!-- PAUSE OVERLAY -->
<div id="pause-overlay" style="display:none;position:absolute;inset:0;background:rgba(5,5,20,.88);
  backdrop-filter:blur(16px);z-index:500;align-items:center;justify-content:center;
  flex-direction:column;gap:18px;pointer-events:auto;">
  <h2 style="color:#fff;font-size:2.2rem;font-family:'Baloo 2',cursive;margin:0;">â¸ Paused</h2>
  <div style="color:rgba(255,255,255,.5);font-size:.9rem;" id="pause-mapinfo"></div>
  <button class="pause-btn pause-resume" onclick="togglePause()">â–¶ Resume</button>
  <button class="pause-btn pause-battery" onclick="toggleBattery()">âš¡ Battery Saver: <span id="bat-label">OFF</span></button>
  <div class="pause-sep"></div>
  <button class="pause-btn pause-feature" onclick="openFeature()">ğŸ’¡ Request a Feature</button>
  <div class="pause-sep"></div>
  <button class="pause-btn pause-quit" onclick="quitGame()">âœ• Quit to Menu</button>
</div>

<!-- FEATURE REQUEST MODAL -->
<div id="feature-modal" style="display:none;position:absolute;inset:0;
  background:rgba(5,5,20,.9);z-index:600;align-items:center;justify-content:center;pointer-events:auto;">
  <div id="feature-box">
    <h3>ğŸ’¡ Request a Feature</h3>
    <p>Got an idea? We'd love to hear it! Your request goes straight to the developer.</p>
    <textarea id="feature-input" placeholder="Describe your feature idea..."></textarea>
    <button id="feature-send" onclick="sendFeature()">ğŸ“¨ Send to Developer</button>
    <button id="feature-close" onclick="closeFeature()">Cancel</button>
  </div>
</div>

<div id="peer-labels"></div>
<div id="name-label" class="fname">Player</div>

<!-- DIALOGUE -->
<div id="dialogue">
  <img class="d-img" id="d-img" src="friend.png"
    onerror="this.onerror=null;this.style.visibility='hidden';"
    alt="Friend">
  <div class="d-text">
    <div class="d-name">Friend ğŸ¢</div>
    "Tiny and the whole family have gone missing! They're scattered everywhere â€” some are hiding in sneaky spots. Beach is next, and Tiny has a secret classroom hideout. Can you find them all?"
  </div>
  <button class="d-btn" onclick="document.getElementById('dialogue').style.display='none'">
    Let's Go!
  </button>
</div>

<!-- SKIN SELECTOR -->
<div id="skin-sel"><span class="sk-lbl">Skin</span></div>

<!-- BANNERS -->
<div id="unlock-banner"></div>
<div id="locked-msg"></div>
<div id="toast"></div>

<!-- CAM HINT -->
<div id="cam-hint">
  <b>Move</b> WASD &nbsp;|&nbsp; <b>Cam</b> Arrow keys / drag<br>
  <b>Jump</b> Space &nbsp;|&nbsp; <b>Crouch</b> C (look under beds!)<br>
  Scroll / pinch = zoom
</div>

<!-- MOBILE -->
<!-- DEV MOBILE BUTTONS -->
<div id="dev-btns">
  <button class="dev-mbtn" onclick="flyMode=!flyMode;showToast(flyMode?'âœˆ Fly ON':'âœˆ Fly OFF')">âœˆ Fly</button>
  <button class="dev-mbtn" onclick="noclipMode=!noclipMode;showToast(noclipMode?'ğŸ‘» Noclip ON':'ğŸ‘» Noclip OFF')">ğŸ‘» Noclip</button>
  <button class="dev-mbtn" onclick="superSpeed=!superSpeed;showToast(superSpeed?'âš¡ Speed ON':'âš¡ Speed OFF')">âš¡ Speed</button>
  <button class="dev-mbtn" onclick="player.position.set(0,20,0);showToast('âŒ‚ Reset')">âŒ‚ Reset</button>
  <button class="dev-mbtn" onclick="adminCollect()">â˜… Collect all</button>
  <button class="dev-mbtn" onclick="camDistTarget=Math.max(4,camDistTarget-4)">ğŸ”+</button>
  <button class="dev-mbtn" onclick="camDistTarget=Math.min(60,camDistTarget+4)">ğŸ”âˆ’</button>
</div>
<!-- ADMIN MOBILE BUTTONS (separate) -->
<div id="admin-btns" style="position:absolute;bottom:175px;left:85px;display:none;flex-direction:column;gap:6px;pointer-events:auto;z-index:160;">
  <button class="dev-mbtn" style="border-color:#cc88ff;color:#cc88ff;" onclick="flyMode=!flyMode;showToast(flyMode?'âœˆ Fly ON':'âœˆ Fly OFF')">âœˆ Fly</button>
  <button class="dev-mbtn" style="border-color:#cc88ff;color:#cc88ff;" onclick="adminCollect()">â˜… Collect</button>
  <button class="dev-mbtn" style="border-color:#cc88ff;color:#cc88ff;" onclick="openFeature()">ğŸ’¡ Feature</button>
</div>
<div id="joy-wrap"><div id="joy-outer"><div id="joy-inner"></div></div></div>
<button id="jump-btn">JUMP</button>
<button id="crouch-btn">CROUCH</button>
</div>

<script>
'use strict';
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONSTANTS & STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SPRITES = ['friend','dad','mum','tiny','brother','sister','admin','dev'];
const SPRITE_FALLBACK_COLORS = {
  friend:'#4ECDC4',dad:'#3498db',mum:'#e91e8c',tiny:'#FFD166',
  brother:'#2980b9',sister:'#e91e63',admin:'#9b59b6',dev:'#27ae60'
};

// Skin groups: finding all of a type unlocks that skin
const SKIN_GROUPS = {dad:'dad',mum:'mum',brother:'brother',sister:'sister',tiny:'tiny'};
// These are special and only unlocked by keys
const KEY_ONLY_SKINS = ['dev','admin'];
// 'friend' is always unlocked (the default skin)
const ALWAYS_UNLOCKED = ['friend'];

let playerName='Player', chosenSprite='friend', accessMode='normal';
let currentMap=1, secondsElapsed=0, timerInterval=null, gameStarted=false;
let flyMode=false, flyVelY=0, velocityY=0, isGrounded=false, isCrouching=false;
let noclipMode=false;
let superSpeed=false;
let batterySaver=false;
let gamePaused=false;
let netSyncCounter=0;

// â”€â”€ BATTERY SAVER â”€â”€
function toggleBattery(){
  batterySaver=!batterySaver;
  document.getElementById('bat-label').textContent=batterySaver?'ON':'OFF';
  document.getElementById('battery-badge').style.display=batterySaver?'block':'none';
  applyBatteryMode();
  showToast(batterySaver?'âš¡ Battery Saver ON â€” optimised for low-end devices':'ğŸ”† High Quality Mode');
}

function applyBatteryMode(){
  if(batterySaver){
    // â•â• BATTERY ON: max performance, 60fps on 10yr old Android â•â•

    // 1. Pixel ratio â€” 0.6 = render at 60% native res, huge GPU win
    renderer.setPixelRatio(0.6);
    renderer.setSize(innerWidth, innerHeight);

    // 2. Kill all shadows completely
    renderer.shadowMap.enabled = false;
    sun.castShadow = false;
    scene.traverse(obj=>{ obj.castShadow=false; obj.receiveShadow=false; });

    // 3. Remove all directional/point lights â€” only flat ambient remains
    sun.intensity = 0;
    fillLight.intensity = 0;
    // Boost ambient so world is still visible without directional lights
    ambient.intensity = 2.0;
    ambient.color.set(0xffffff);
    hemiLight.intensity = 1.5;

    // 4. Kill tone mapping (expensive post-process)
    renderer.toneMapping = THREE.NoToneMapping;
    renderer.toneMappingExposure = 1.0;

    // 5. Heavy fog = GPU renders far fewer objects
    scene.fog.density = 0.018; // very short render distance

    // 6. Freeze day/night â€” lock to midday (no per-frame sin/cos/color updates)
    dayT = Math.PI * 0.5; // noon, frozen

    // 7. Low bitrate VC
    if(localStream){
      localStream.getAudioTracks().forEach(t=>{
        try{ t.applyConstraints({sampleRate:8000,channelCount:1,echoCancellation:true}); } catch(e){}
      });
    }

    // 8. Hide sky dome (saves vertex shader cost)
    skyMesh.visible = false;
    scene.background = new THREE.Color(0x87ceeb);

    // 9. Hide ALL grass blades â€” each is a draw call
    grassBlades.forEach(g=>g.visible=false);

    // 10. Reduce camera far plane to cull more geometry
    camera.far = 200;
    camera.updateProjectionMatrix();

  } else {
    // â•â• BATTERY OFF: maximum quality â•â•

    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);

    // Re-enable shadows
    renderer.shadowMap.enabled = true;
    sun.castShadow = true;
    // Re-enable cast/receive on scene objects
    scene.traverse(obj=>{
      if(obj.userData.deco||obj.isMesh){
        obj.castShadow = !obj.userData.noShadow;
        obj.receiveShadow = true;
      }
    });

    // Restore tone mapping
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.4;

    // Restore fog to map default
    setLighting(currentMap);

    // Restore sky dome
    skyMesh.visible = true;
    scene.background = null;

    // Restore grass and camera
    grassBlades.forEach(g=>g.visible=true);
    camera.far = 1500;
    camera.updateProjectionMatrix();

    // Restore VC
    if(localStream){
      localStream.getAudioTracks().forEach(t=>{
        try{ t.applyConstraints({sampleRate:48000,channelCount:2}); } catch(e){}
      });
    }

    // Unfreeze day/night (lighting restored in animate loop)
    lastSunH = -1; // force sky redraw
  }
}

// â”€â”€ PAUSE â”€â”€
function togglePause(){
  gamePaused=!gamePaused;
  const ol=document.getElementById('pause-overlay');
  ol.style.display=gamePaused?'flex':'none';
  ol.style.pointerEvents=gamePaused?'auto':'none';
  if(gamePaused){
    const tot=famFound.dad+famFound.mum+famFound.brother+famFound.sister+famFound.tiny;
    document.getElementById('pause-mapinfo').textContent=`Map ${currentMap} Â· Found ${tot}/20`;
  }
}
function quitGame(){
  gamePaused=false;
  document.getElementById('pause-overlay').style.display='none';
  document.getElementById('pause-btn').style.display='none';
  document.getElementById('game-ui').style.display='none';
  document.getElementById('joy-wrap').style.display='none';
  document.getElementById('jump-btn').style.display='none';
  document.getElementById('crouch-btn').style.display='none';
  document.getElementById('skin-sel').style.display='none';
  document.getElementById('menu').style.display='flex';
  gameStarted=false;
  if(peer){ peer.destroy(); peer=null; }
}

// â”€â”€ FEATURE REQUEST â”€â”€
function openFeature(){
  document.getElementById('pause-overlay').style.display='none';
  document.getElementById('feature-modal').style.display='flex';
}
function closeFeature(){
  document.getElementById('feature-modal').style.display='none';
  document.getElementById('pause-overlay').style.display='flex';
}
async function sendFeature(){
  const txt=document.getElementById('feature-input').value.trim();
  if(!txt){ showToast('Please enter your idea first!'); return; }
  // Send via mailto as fallback (no backend)
  const subject=encodeURIComponent('Find Tiny Feature Request');
  const body=encodeURIComponent('Feature Request:\n\n'+txt+'\n\nFrom: '+playerName);
  window.open('mailto:dacoolkid325@gmail.com?subject='+subject+'&body='+body);
  document.getElementById('feature-input').value='';
  closeFeature();
  showToast('ğŸ“¨ Opening email to send request!');
}

let famTargets = {dad:1,mum:1,brother:8,sister:9,tiny:1}; // 20 total
let famFound   = {dad:0,mum:0,brother:0,sister:0,tiny:0};
let groupUnlocked = {};

// â”€â”€ PERSISTENT UNLOCK STORAGE â”€â”€
// Only 'friend' is available by default. Everything else must be earned.
function loadUnlocked(){
  try{
    const saved=JSON.parse(localStorage.getItem('ftf_unlocked')||'[]');
    // Always include 'friend', merge saved
    const base=[...ALWAYS_UNLOCKED];
    saved.forEach(s=>{ if(!base.includes(s)) base.push(s); });
    return base;
  } catch(e){ return [...ALWAYS_UNLOCKED]; }
}
function saveUnlocked(){
  try{ localStorage.setItem('ftf_unlocked',JSON.stringify(unlockedSkins)); } catch(e){}
}

let unlockedSkins = loadUnlocked();
let currentSkin = unlockedSkins[0]; // friend by default

let familyMeshes=[], obstacles=[], grassBlades=[], cloudMeshes=[];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MENU â€” animated stars
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
(function buildMenuStars(){
  const c=document.getElementById('menu-stars');
  for(let i=0;i<80;i++){
    const s=document.createElement('div');
    s.className='star';
    const sz=Math.random()*2+1;
    s.style.cssText=`width:${sz}px;height:${sz}px;top:${Math.random()*100}%;left:${Math.random()*100}%;animation-delay:${Math.random()*4}s;animation-duration:${2+Math.random()*3}s;`;
    c.appendChild(s);
  }
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SPRITE PICKER â€” locked sprites shown greyed with padlock
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildSpritePicker(){
  const row=document.getElementById('sprite-row');
  row.innerHTML='';
  SPRITES.forEach(name=>{
    const isUnlocked=unlockedSkins.includes(name);
    const wrap=document.createElement('div');
    wrap.style.cssText='position:relative;display:inline-block;';

    const img=document.createElement('img');
    img.className='sprite-opt';
    img.src=name+'.png';
    img.title=isUnlocked ? name[0].toUpperCase()+name.slice(1) : 'ğŸ”’ Locked';
    img.dataset.name=name;
    if(!isUnlocked){ img.style.filter='grayscale(1) brightness(.4)'; img.style.cursor='not-allowed'; }

    img.onerror=function(){
      const cv=document.createElement('canvas'); cv.width=cv.height=48;
      const ctx=cv.getContext('2d');
      // No initials/text â€” just a colored circle placeholder
      ctx.fillStyle=isUnlocked?(SPRITE_FALLBACK_COLORS[name]||'#555'):'#222';
      ctx.beginPath(); ctx.arc(24,24,22,0,Math.PI*2); ctx.fill();
      if(!isUnlocked){
        // draw lock symbol
        ctx.fillStyle='#888'; ctx.fillRect(18,22,12,10); ctx.beginPath();
        ctx.arc(24,22,5,Math.PI,0); ctx.strokeStyle='#888'; ctx.lineWidth=2; ctx.stroke();
      }
      img.src=cv.toDataURL();
    };

    if(isUnlocked){
      img.onclick=()=>{
        document.querySelectorAll('.sprite-opt').forEach(x=>x.classList.remove('chosen'));
        img.classList.add('chosen'); chosenSprite=name;
        localStorage.setItem('ftf_lastSprite',name);
      };
    } else {
      // Show lock icon overlay
      const lock=document.createElement('div');
      lock.textContent='ğŸ”’';
      lock.style.cssText='position:absolute;top:0;right:0;font-size:14px;pointer-events:none;';
      wrap.appendChild(lock);
    }

    wrap.appendChild(img);
    row.appendChild(wrap);
  });

  // Restore last chosen sprite if still unlocked, else default to friend
  const last=localStorage.getItem('ftf_lastSprite');
  const defaultChoice=last&&unlockedSkins.includes(last)?last:'friend';
  chosenSprite=defaultChoice;
  const target=row.querySelector(`img[data-name="${defaultChoice}"]`);
  if(target) target.classList.add('chosen');
}
buildSpritePicker();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ACCESS KEY SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const KEYS={'212121':'dev','221122':'admin'};
function openKey(){ document.getElementById('key-modal').style.display='flex'; setTimeout(()=>document.getElementById('key-input').focus(),120); }
function closeKey(){ document.getElementById('key-modal').style.display='none'; }
document.getElementById('key-input').addEventListener('keydown',e=>{ if(e.key==='Enter')submitKey(); if(e.key==='Escape')closeKey(); });

function submitKey(){
  const v=document.getElementById('key-input').value.trim();
  const ks=document.getElementById('key-status');
  const mode=KEYS[v];
  if(mode){
    accessMode=mode;
    ks.style.color='#00FF88';
    if(mode==='dev'){
      ks.textContent='âœ” Dev Mode unlocked!';
      // Dev only gets dev skin (not family skins â€” those must be earned)
      giveExtraSkins(['dev']);
    } else {
      ks.textContent='âœ” Admin Mode unlocked!';
      // Admin gets dev + admin skins. Family skins still must be earned in-game.
      // (adminCollect will auto-collect family, triggering group unlocks properly)
      giveExtraSkins(['dev','admin']);
    }
    if(gameStarted){ buildSkinSel(); updateModeTag(); if(mode==='admin') adminCollect(); }
    setTimeout(closeKey,1800);
  } else {
    ks.style.color='#FF4444'; ks.textContent='âœ˜ Wrong key.';
    document.getElementById('key-input').value='';
    document.getElementById('key-input').focus();
  }
}
function giveExtraSkins(arr){ let changed=false; arr.forEach(s=>{ if(!unlockedSkins.includes(s)){ unlockedSkins.push(s); changed=true; } }); if(changed){ saveUnlocked(); buildSpritePicker(); } }
function updateModeTag(){
  const mt=document.getElementById('mode-tag');
  if(accessMode==='dev')  { mt.textContent='ğŸ›  Dev Mode';   mt.style.display='inline-block'; document.getElementById('dev-panel').style.display='block'; document.getElementById('dev-btns').style.display='flex'; }
  if(accessMode==='admin'){ mt.textContent='ğŸ‘‘ Admin Mode'; mt.style.display='inline-block'; if(gameStarted) document.getElementById('admin-btns').style.display='flex'; }
}
function adminCollect(){
  for(let i=familyMeshes.length-1;i>=0;i--){
    const f=familyMeshes[i]; scene.remove(f.mesh);
    famFound[f.type]++; checkGroupUnlock(f.type); familyMeshes.splice(i,1);
  }
  updateHUD(); showToast('ğŸ‘‘ All family collected!');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  VOICE CHAT (up to 10 players)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let peer, peers={}, localStream=null, micEnabled=false;

async function enableVC(){
  const btn=document.getElementById('vc-btn'); btn.disabled=true; btn.textContent='Requesting mic...';
  try{
    localStream=await navigator.mediaDevices.getUserMedia({audio:true});
    localStream.getAudioTracks()[0].enabled=false;
    btn.textContent='âœ” Voice Chat Ready'; btn.style.background='linear-gradient(135deg,#27ae60,#2ecc71)';
    document.getElementById('mic-btn').style.display='flex';
    showToast('Voice chat ready â€” tap mic to unmute');
  } catch(e){
    btn.disabled=false; btn.textContent='Enable Voice Chat';
    showToast('Mic denied: '+e.message);
  }
}
function toggleMic(){
  if(!localStream) return;
  micEnabled=!micEnabled;
  localStream.getAudioTracks()[0].enabled=micEnabled;
  const btn=document.getElementById('mic-btn');
  btn.style.background=micEnabled?'rgba(39,174,96,.8)':'rgba(10,10,26,.85)';
}

function initNet(code){
  const tag=document.getElementById('room-tag');
  const st=document.getElementById('conn-status');
  try{
    const myId=code?null:Math.random().toString(36).substr(2,6).toUpperCase();
    peer=new Peer(myId);
    peer.on('open',id=>{
      if(code){ tag.textContent='Lobby: '+code; connectTo(code); }
      else { tag.textContent='Host: '+id; st.innerHTML=`Code: <b style="font-size:1.2rem">${id}</b>`; }
    });
    peer.on('error',e=>{ tag.textContent='Net error'; console.warn(e.type); });
    peer.on('connection',conn=>handleConn(conn));
    peer.on('call',call=>{ if(localStream) call.answer(localStream); call.on('stream',s=>playStream(s)); });
  } catch(e){ tag.textContent='Offline'; }
}
function connectTo(id){
  if(Object.keys(peers).length>=10){ showToast('Max 10 players'); return; }
  const conn=peer.connect(id); handleConn(conn);
  if(localStream){ const c=peer.call(id,localStream); c.on('stream',s=>playStream(s)); }
}
function handleConn(conn){
  conn.on('open',()=>conn.send({type:'init',name:playerName,sprite:chosenSprite}));
  conn.on('data',data=>{
    if(!peers[conn.peer]) makePeerMesh(conn.peer);
    const p=peers[conn.peer];
    if(data.type==='init'){ loadSpriteFor(p.mesh,data.sprite); p.labelDiv.innerText=data.name; p.conn=conn; }
    else if(data.type==='move'){ p.mesh.position.set(data.x,data.y,data.z); p.mesh.lookAt(camera.position.x,data.y,camera.position.z); }
  });
  conn.on('close',()=>{ if(peers[conn.peer]){ scene.remove(peers[conn.peer].mesh); peers[conn.peer].labelDiv.remove(); delete peers[conn.peer]; } });
}
function makePeerMesh(id){
  const mesh=new THREE.Mesh(new THREE.PlaneGeometry(2,2.2),new THREE.MeshStandardMaterial({color:0xffffff,side:THREE.DoubleSide,transparent:true}));
  mesh.castShadow=true; scene.add(mesh);
  const lbl=document.createElement('div'); lbl.className='fname'; lbl.style.display='block'; lbl.innerText='Player';
  document.getElementById('peer-labels').appendChild(lbl);
  peers[id]={mesh,labelDiv:lbl,conn:null};
}
function loadSpriteFor(mesh,spriteName){
  tLoader.load(spriteName+'.png',tex=>{ mesh.material.map=tex; mesh.material.color.set(0xFFFFFF); mesh.material.needsUpdate=true; },null,()=>{ mesh.material.color.set(SPRITE_FALLBACK_COLORS[spriteName]||'#fff'); });
}
function playStream(stream){ const a=document.createElement('audio'); a.srcObject=stream; a.autoplay=true; a.style.display='none'; document.body.appendChild(a); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  THREE.JS CORE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(65,innerWidth/innerHeight,.1,1500); // wider far plane = more visible
// Detect if mobile for initial quality hints
const isMobile=/Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
const renderer=new THREE.WebGLRenderer({
  antialias:!isMobile,          // AA off on mobile by default
  powerPreference:'high-performance',
  precision: isMobile?'mediump':'highp'
});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, isMobile?1.5:2));
renderer.shadowMap.enabled=true;
renderer.shadowMap.type=THREE.PCFSoftShadowMap;
renderer.toneMapping=THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure=1.4;
document.body.insertBefore(renderer.domElement,document.getElementById('ui'));

const tLoader=new THREE.TextureLoader();

// â”€â”€ LIGHTING â”€â”€
const hemiLight=new THREE.HemisphereLight(0xffe5a0,0x3a7010,1.2);
scene.add(hemiLight);

const sun=new THREE.DirectionalLight(0xffdd55,2.6);
sun.castShadow=true;
sun.shadow.mapSize.width=sun.shadow.mapSize.height=isMobile?1024:2048;
sun.shadow.camera.near=1; sun.shadow.camera.far=600;
sun.shadow.camera.left=-200; sun.shadow.camera.right=200;
sun.shadow.camera.top=200;   sun.shadow.camera.bottom=-200;
sun.shadow.bias=-0.0005;
sun.shadow.normalBias=0.02;
scene.add(sun);

// Secondary fill light from opposite side
const fillLight=new THREE.DirectionalLight(0x4488ff,.35);
fillLight.position.set(-1,.5,-1);
scene.add(fillLight);

const ambient=new THREE.AmbientLight(0xffd0a0,.25);
scene.add(ambient);

// Day/night cycle â€” starts at dawn (~6am feel)
let dayT=Math.PI*0.08;  // dawn
let lastSunH=-1;
const DAY_SPEED=0.00012; // full cycle ~14 min

scene.fog=new THREE.FogExp2(0xffe8b0,.0015);
scene.background=new THREE.Color(0xff9944);

// â”€â”€ SKY DOME â”€â”€
const SKY_SEGS=12;
const skyGeo=new THREE.SphereGeometry(900,SKY_SEGS,SKY_SEGS*.5);
skyGeo.scale(-1,1,-1); // invert normals so it's visible from inside
// Gradient: warm orange at horizon, deep blue at apex â€” updated each frame
const skyColors=new Float32Array(skyGeo.attributes.position.count*3);
skyGeo.setAttribute('color',new THREE.BufferAttribute(skyColors,3));
const skyMat=new THREE.MeshBasicMaterial({vertexColors:true,depthWrite:false,fog:false});
const skyMesh=new THREE.Mesh(skyGeo,skyMat);
skyMesh.renderOrder=-1;
scene.add(skyMesh);

function updateSky(sunH,sinT){
  const pos=skyGeo.attributes.position;
  const col=skyGeo.attributes.color;
  // top = apex deep blue (night) or sky blue (day)
  // horizon = warm orange (dawn/dusk) or pale sky (day) or near-black (night)
  const apex   = sunH>0.01 ? new THREE.Color(0x1a6ecc).lerp(new THREE.Color(0x0a2a60),Math.max(0,1-sunH*2)) : new THREE.Color(0x050520);
  const midSky = sunH>0.01 ? new THREE.Color(0x44aaee).lerp(new THREE.Color(0x88ccff),sunH) : new THREE.Color(0x101840);
  const horiz  = sunH>0.01 ? new THREE.Color(0xff7700).lerp(new THREE.Color(0xbbddff),Math.min(1,sunH*2)) : new THREE.Color(0x1a0808);
  if(sunH<.02){ // dawn tinge
    horiz.set(0xff5500);
    midSky.set(0x331122);
  }
  for(let i=0;i<pos.count;i++){
    const yN=Math.max(-1,Math.min(1,pos.getY(i)/900)); // -1 to 1
    const t=Math.max(0,yN); // 0 at horizon, 1 at top
    let c;
    if(t<0.15) c=horiz.clone().lerp(midSky,t/0.15);
    else c=midSky.clone().lerp(apex,(t-.15)/.85);
    col.setXYZ(i,c.r,c.g,c.b);
  }
  col.needsUpdate=true;
}

// â”€â”€ TERRAIN â”€â”€
const terrainMats={
  1:new THREE.MeshStandardMaterial({color:0x4a8c28,roughness:.9,metalness:0}),
  2:new THREE.MeshStandardMaterial({color:0xf0d090,roughness:.85,metalness:0}),
  3:new THREE.MeshStandardMaterial({color:0xd4c4a0,roughness:.7,metalness:0})
};
tLoader.load('grass.png',tex=>{ tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.repeat.set(80,80); terrainMats[1].map=tex; terrainMats[1].needsUpdate=true; },null,()=>{});

let terrain=null;
// House flat pads â€” populated before buildTerrain so terrain can flatten under them
const HOUSE_PADS=[
  {x:30,z:30},{x:80,z:-20},{x:-60,z:50},{x:50,z:-80},{x:-90,z:-30},
  {x:110,z:70},{x:-40,z:-120},{x:0,z:110},{x:130,z:-100},
  {x:-120,z:80},{x:70,z:150},{x:-150,z:-80},{x:20,z:-160},{x:160,z:20},{x:-80,z:160}
];
const PAD_R=18; // flatten radius around each house centre

function buildTerrain(m){
  if(terrain){ scene.remove(terrain); terrain.geometry.dispose(); terrain=null; }
  const size = m===3 ? 140 : 800;
  const segs = m===3 ? 4   : 80;
  const geo=new THREE.PlaneGeometry(size,size,segs,segs);
  geo.rotateX(-Math.PI/2);
  if(m!==3){
    const pos=geo.attributes.position;
    for(let i=0;i<pos.count;i++){
      const x=pos.getX(i),z=pos.getZ(i);
      let y=0;
      if(m===1){
        y = Math.sin(x*0.012)*Math.cos(z*0.012)*18
          + Math.sin(x*0.03+1)*Math.cos(z*0.025+2)*8
          + Math.sin(x*0.07)*Math.cos(z*0.08)*3;
        // Hard flatten: vertices inside pad radius get y=0, taper in outer 5 units
        let flatBlend=0;
        for(const pad of HOUSE_PADS){
          const dist=Math.sqrt((x-pad.x)**2+(z-pad.z)**2);
          if(dist<PAD_R){
            const inner=PAD_R-5;
            flatBlend=Math.max(flatBlend, dist<=inner ? 1 : 1-(dist-inner)/5);
          }
        }
        y=y*(1-flatBlend);
      }
      // m===2: y stays 0 (beach flat)
      pos.setY(i,y);
    }
    geo.computeVertexNormals();
  }
  terrain=new THREE.Mesh(geo,terrainMats[m]);
  terrain.receiveShadow=true; scene.add(terrain);
}

// â”€â”€ PLAYER â”€â”€
const playerGeo=new THREE.PlaneGeometry(2.4,2.7);
const playerMat=new THREE.MeshStandardMaterial({color:0x4ECDC4,side:THREE.DoubleSide,transparent:true,alphaTest:.05});
const player=new THREE.Mesh(playerGeo,playerMat);
player.castShadow=true; scene.add(player);

const disc=new THREE.Mesh(new THREE.CircleGeometry(.9,16),new THREE.MeshBasicMaterial({color:0,transparent:true,opacity:.22}));
disc.rotation.x=-Math.PI/2; scene.add(disc);

// â”€â”€ CLOUDS â”€â”€
// clouds removed

// â”€â”€ RAYCASTER â”€â”€
const gRay=new THREE.Raycaster();
const dVec=new THREE.Vector3(0,-1,0);
// Cache terrain heights for player pos to avoid per-frame raycasting overhead
const _thCache=new Map();
function terrainH(x,z){
  if(!terrain) return 0;
  // Round to 1 decimal for caching â€” good enough for terrain
  const key=(Math.round(x*2)/2)+','+(Math.round(z*2)/2);
  if(_thCache.has(key)) return _thCache.get(key);
  gRay.set(new THREE.Vector3(x,500,z),dVec);
  const h=gRay.intersectObject(terrain);
  const y=h.length?h[0].point.y:0;
  if(_thCache.size>2000) _thCache.clear(); // prevent unbounded growth
  _thCache.set(key,y);
  return y;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CAMERA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let camYaw=0, camPitch=.42, camDist=22, camDistTarget=22;
const housePositions=[]; // filled by addHouse
const CAM_SPD=.03;

let mDrag=false,lmx=0,lmy=0;
renderer.domElement.addEventListener('mousedown',e=>{ if(e.button===0){mDrag=true;lmx=e.clientX;lmy=e.clientY;} });
renderer.domElement.addEventListener('mousemove',e=>{ if(!mDrag) return; camYaw-=(e.clientX-lmx)*.004; camPitch-=(e.clientY-lmy)*.004; camPitch=clamp(camPitch,.05,1.45); lmx=e.clientX;lmy=e.clientY; });
renderer.domElement.addEventListener('mouseup',()=>mDrag=false);
renderer.domElement.addEventListener('mouseleave',()=>mDrag=false);
renderer.domElement.addEventListener('wheel',e=>{ camDistTarget=clamp((camDistTarget||camDist)+e.deltaY*.06,4,80); },{passive:true});

const camt={};
renderer.domElement.addEventListener('touchstart',e=>{ for(const t of e.changedTouches) if(t.clientX>innerWidth*.45) camt[t.identifier]={x:t.clientX,y:t.clientY}; },{passive:true});
renderer.domElement.addEventListener('touchmove',e=>{ for(const t of e.changedTouches){ if(camt[t.identifier]){ const p=camt[t.identifier]; camYaw-=(t.clientX-p.x)*.005; camPitch-=(t.clientY-p.y)*.005; camPitch=clamp(camPitch,.05,1.45); camt[t.identifier]={x:t.clientX,y:t.clientY}; e.preventDefault(); } } },{passive:false});
renderer.domElement.addEventListener('touchend',e=>{ for(const t of e.changedTouches) delete camt[t.identifier]; },{passive:true});

// Track which house player is currently inside
let insideHouseIdx=-1;
function doUpdateCamera(){
  // House proximity â€” find if inside any house
  insideHouseIdx=-1;
  if(currentMap===1 && housePositions.length){
    let nearest=9999, nearestDoor=9999;
    for(let i=0;i<housePositions.length;i++){
      const h=housePositions[i];
      const dx=player.position.x-h.x, dz=player.position.z-h.z;
      const inside=Math.abs(dx)<h.w/2-0.5&&Math.abs(dz)<h.d/2-0.5;
      if(inside){ insideHouseIdx=i; nearest=0; break; }
      const dist=Math.sqrt(dx*dx+dz*dz);
      nearest=Math.min(nearest,dist);
    }
    // Inside: zoom right in so walls fill frame; door area: pull back slightly
    if(insideHouseIdx>=0) camDistTarget=8;
    else if(nearest<6) camDistTarget=13;
    else camDistTarget=22;
  } else {
    camDistTarget=currentMap===3?11:22;
  }
  camDist+=(camDistTarget-camDist)*.1;

  // Crouch: lower camera pitch (look along ground), raise target dist slightly
  const crouchPitch = isCrouching ? 0.06 : camPitch;
  const crouchDist  = isCrouching ? camDist*.85 : camDist;
  const lookH = isCrouching ? 0.3 : 1.2; // look at foot level when crouching
  camera.position.set(
    player.position.x+Math.sin(camYaw)*crouchDist*Math.cos(crouchPitch),
    player.position.y+Math.sin(crouchPitch)*crouchDist,
    player.position.z+Math.cos(camYaw)*crouchDist*Math.cos(crouchPitch)
  );
  camera.lookAt(player.position.x,player.position.y+lookH,player.position.z);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SKINS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SKIN_IMGS={friend:'friend.png',dad:'dad.png',mum:'mum.png',brother:'brother.png',sister:'sister.png',tiny:'tiny.png',admin:'admin.png',dev:'dev.png'};
const skinCache={};
function loadSkinTex(name,cb){
  if(name in skinCache){cb(skinCache[name]);return;}
  if(!SKIN_IMGS[name]){skinCache[name]=null;cb(null);return;}
  tLoader.load(SKIN_IMGS[name],t=>{skinCache[name]=t;cb(t);},null,()=>{skinCache[name]=null;cb(null);});
}
function applySkin(name){
  currentSkin=name;
  loadSkinTex(name,tex=>{
    playerMat.map=tex||null;
    playerMat.color.set(tex?0xFFFFFF:SPRITE_FALLBACK_COLORS[name]||0x4ECDC4);
    playerMat.needsUpdate=true;
  });
  document.querySelectorAll('.sk-btn').forEach(b=>b.classList.toggle('sk-active',b.dataset.s===name));
  // Keep dialogue portrait in sync with current skin
  const dImg=document.getElementById('d-img');
  if(dImg){
    dImg.src=name+'.png';
    dImg.onerror=function(){ this.onerror=null; this.style.visibility='hidden'; this.style.background=SPRITE_FALLBACK_COLORS[name]||'#4ECDC4'; };
  }
  const dName=document.querySelector('#dialogue .d-name');
  if(dName) dName.textContent=(name[0].toUpperCase()+name.slice(1))+' ğŸ¢';
}
let skinSelCollapsed=false;
function buildSkinSel(){
  const sel=document.getElementById('skin-sel');
  // Minimise button
  let minBtn=sel.querySelector('.sk-min');
  if(!minBtn){
    minBtn=document.createElement('button'); minBtn.className='sk-min';
    minBtn.textContent=skinSelCollapsed?'â–² Skin':'â–¼';
    minBtn.onclick=e=>{ e.stopPropagation(); skinSelCollapsed=!skinSelCollapsed; buildSkinSel(); };
    sel.appendChild(minBtn);
  }
  // Rebuild content
  sel.innerHTML='';
  // Re-add minimise button
  const mb=document.createElement('button'); mb.className='sk-min';
  mb.textContent=skinSelCollapsed?'â–² Skin':'â–¼ Hide';
  mb.onclick=e=>{ e.stopPropagation(); skinSelCollapsed=!skinSelCollapsed; buildSkinSel(); };
  sel.appendChild(mb);
  if(!skinSelCollapsed){
    const lbl=document.createElement('span'); lbl.className='sk-lbl'; lbl.textContent='Skin'; sel.appendChild(lbl);
    unlockedSkins.forEach(s=>{
      const b=document.createElement('button'); b.className='sk-btn'; b.dataset.s=s;
      b.textContent=s==='dev'?'Dev':s==='admin'?'Admin':s[0].toUpperCase()+s.slice(1);
      if(s==='dev') b.classList.add('sk-dev');
      if(s==='admin') b.classList.add('sk-admin');
      if(s===currentSkin) b.classList.add('sk-active');
      b.onclick=()=>applySkin(s); sel.appendChild(b);
    });
  }
  sel.style.display = unlockedSkins.length > 1 ? 'flex' : 'none';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FAMILY SPAWN â€” Map 1: 9, Map 2: 10, Map 3: Tiny only
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Distribution across maps:
// Map1: dad, mum, 4 brothers, 4 sisters  = 10 (but tiny not here) = 9 non-tiny + 0
// Map2: 4 brothers, 5 sisters = 10 (beach) â€” tortoises on dry sand
// Map3: tiny only

// Family totals: dad=1 mum=1 brother=8 sister=9 tiny=1 = 20
// Map1(9): dad mum 4bro 3sis | Map2(10): 4bro 6sis | Map3(1): tiny
const MAP_ROSTER = {
  1:[{type:'dad',s:2.4},{type:'mum',s:2.2},
     {type:'brother',s:1.9},{type:'brother',s:1.9},{type:'brother',s:1.9},{type:'brother',s:1.9},
     {type:'sister',s:1.7},{type:'sister',s:1.7},{type:'sister',s:1.7}],
  2:[{type:'brother',s:1.9},{type:'brother',s:1.9},{type:'brother',s:1.9},{type:'brother',s:1.9},
     {type:'sister',s:1.7},{type:'sister',s:1.7},{type:'sister',s:1.7},{type:'sister',s:1.7},{type:'sister',s:1.7},{type:'sister',s:1.7}],
  3:[{type:'tiny',s:1.0}]
};

// Hard hiding spots for map 1 â€” behind/under things
// Hard spots: [x,z] pairs â€” inside or near houses
const HARD_SPOTS_MAP1 = [
  [30,30],[80,-20],[-60,50],[50,-80],[-90,-30],
  [110,70],[-40,-120],[0,110],[130,-100]
];

function spawnFamily(){
  if(currentMap===3) return; // Tiny is spawned synchronously inside buildClassroom
  const roster=MAP_ROSTER[currentMap]||[];
  // Synchronous â€” terrain is already built by now
  roster.forEach((mem,idx)=>{
    const mat=new THREE.MeshStandardMaterial({
      color:typeCol(mem.type),side:THREE.DoubleSide,transparent:true,alphaTest:.05
    });
    tLoader.load(mem.type+'.png',
      tex=>{ mat.map=tex; mat.color.set(0xFFFFFF); mat.needsUpdate=true; },
      null, ()=>{}
    );
    const mesh=new THREE.Mesh(new THREE.PlaneGeometry(mem.s,mem.s*1.3),mat);
    let mx,mz;
    if(currentMap===1 && HARD_SPOTS_MAP1[idx]){
      const hs=HARD_SPOTS_MAP1[idx];
      mx=hs[0]+(Math.random()-.5)*6; mz=hs[1]+(Math.random()-.5)*6;
    } else if(currentMap===2){
      mx=(Math.random()-.5)*460; mz=(Math.random()-.5)*180;
      if(mz<-120) mz=-90+Math.random()*40;
    } else {
      mx=(Math.random()-.5)*380; mz=(Math.random()-.5)*380;
    }
    let ty=0;
    try{ ty=terrainH(mx,mz); } catch(e){ ty=0; }
    if(!isFinite(ty)||ty==null) ty=0;
    mesh.position.set(mx, ty+mem.s*.6+.1, mz);
    mesh.castShadow=false;
    scene.add(mesh);
    familyMeshes.push({mesh,type:mem.type});
  });
}

function typeCol(t){ return {dad:0x3498db,mum:0xe91e8c,brother:0x2980b9,sister:0xe91e63,tiny:0xFFD166}[t]||0xffffff; }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MAP BUILDERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function mkMesh(geo,params){ return new THREE.Mesh(geo,new THREE.MeshStandardMaterial(params)); }

function clearScene(){
  _thCache.clear();
  // famFound intentionally NOT reset â€” carries across maps
  familyMeshes.forEach(f=>scene.remove(f.mesh));
  obstacles.forEach(o=>scene.remove(o.mesh||o));
  grassBlades.forEach(g=>scene.remove(g));
  scene.children.filter(c=>c.userData.deco).forEach(c=>scene.remove(c));
  familyMeshes=[]; obstacles=[]; grassBlades=[]; housePositions.length=0;
}

function loadMap(m){
  clearScene(); buildTerrain(m); setLighting(m);
  if(m===1) buildNeighborhood();
  else if(m===2) buildBeach();
  else buildClassroom();
  player.position.set(0,20,0); flyVelY=0; velocityY=0; isGrounded=false;
  document.getElementById('c-map').textContent='Map '+m;
  updateHUD();
  if(accessMode==='admin') setTimeout(adminCollect,400);
}

// â”€â”€ LIGHTING PER MAP â”€â”€
function setLighting(m){
  if(batterySaver) return; // battery saver controls its own lighting
  if(m===1){
    hemiLight.color.set(0xffeaa0); hemiLight.groundColor.set(0x4a7a20); hemiLight.intensity=1.1;
    ambient.color.set(0xffd0a0); ambient.intensity=.3;
    scene.fog.color.set(0xffcc88); scene.fog.density=.0014;
  } else if(m===2){
    hemiLight.color.set(0xaaddff); hemiLight.groundColor.set(0xf0d090); hemiLight.intensity=1.3;
    ambient.color.set(0xbbeeff); ambient.intensity=.35;
    scene.fog.color.set(0x88ccff); scene.fog.density=.001;
  } else {
    hemiLight.color.set(0xffeedd); hemiLight.groundColor.set(0x997755); hemiLight.intensity=.8;
    ambient.color.set(0xffddbf); ambient.intensity=.5;
    scene.fog.color.set(0xeeddcc); scene.fog.density=.007;
  }
}

// â”€â”€ MAP 1: NEIGHBORHOOD â”€â”€
function buildNeighborhood(){
  // Use HOUSE_PADS (already defined, matches terrain flat areas)
  HOUSE_PADS.forEach(({x,z})=>{ addHouse(x,0,z); }); // ty=0 since terrain is flat there

  // Trees â€” avoid house areas
  for(let i=0;i<60;i++){
    const tx=(Math.random()-.5)*700, tz=(Math.random()-.5)*700;
    // Skip if too close to any house
    const nearHouse=HOUSE_PADS.some(h=>Math.sqrt((tx-h.x)**2+(tz-h.z)**2)<PAD_R+4);
    if(!nearHouse) addTree(tx,tz);
  }

  // Rocks
  for(let i=0;i<30;i++){
    const s=Math.random()*3+1;
    const rx=(Math.random()-.5)*650, rz=(Math.random()-.5)*650;
    const nearHouse=HOUSE_PADS.some(h=>Math.sqrt((rx-h.x)**2+(rz-h.z)**2)<PAD_R+2);
    if(nearHouse) continue;
    const rock=mkMesh(new THREE.DodecahedronGeometry(s,0),{color:0x777777,roughness:.95,metalness:.05});
    rock.position.set(rx,terrainH(rx,rz)+s*.4,rz); rock.receiveShadow=true; rock.userData.deco=true; scene.add(rock);
    obstacles.push({mesh:rock,radius:s*1.1,x:rx,z:rz});
  }

  spawnGrass(80,700);
  spawnFamily();
}

function addHouse(x,ty,z){
  // ty=0 since terrain is flat at house pads
  const W=18, D=16, H=8, WT=1.0;
  const DOOR_W=3.2, DOOR_H=4.4;
  const idx=housePositions.length;
  const wallCols=[0xF2E0C0,0xDDE8DC,0xF5D9A8,0xE8D8C0,0xD0E0D0,0xEEDDCC];
  const roofCols=[0xA03020,0x6B2E1A,0x2A5078,0x404040,0x703010];
  const wMat=new THREE.MeshStandardMaterial({color:wallCols[idx%wallCols.length],roughness:.88});
  const rMat=new THREE.MeshStandardMaterial({color:roofCols[idx%roofCols.length],roughness:.92});
  const fMat=new THREE.MeshStandardMaterial({color:0xC8A878,roughness:.7});
  const winMat=new THREE.MeshStandardMaterial({color:0x88CCFF,roughness:.05,metalness:.2,transparent:true,opacity:.55});
  const frMat=new THREE.MeshStandardMaterial({color:0xDDDDDD,roughness:.8});
  const dMat=new THREE.MeshStandardMaterial({color:0x5a3010,roughness:.85});

  function box(geo,mat,px,py,pz,ry){
    const m=new THREE.Mesh(geo,mat);
    m.position.set(px,py,pz);
    if(ry) m.rotation.y=ry;
    m.castShadow=true; m.receiveShadow=true; m.userData.deco=true; scene.add(m); return m;
  }

  // â”€â”€ FLOOR SLAB â€” thick, sinks 5u into ground, no gaps â”€â”€
  // Use terrain colour so no colour extension visible
  box(new THREE.BoxGeometry(W+WT*2+1,10,D+WT*2+1),
    new THREE.MeshStandardMaterial({color:0x4a8c28,roughness:.9}), x,-5,z);
  // Interior floor on top
  box(new THREE.BoxGeometry(W-0.2,0.2,D-0.2),fMat, x,0.1,z);

  // â”€â”€ WALLS â”€â”€
  const fSide=(W-DOOR_W)/2;
  box(new THREE.BoxGeometry(W+WT*2,H,WT),wMat, x,H/2,z-D/2-WT/2);         // back
  box(new THREE.BoxGeometry(WT,H,D+WT*2),wMat, x-W/2-WT/2,H/2,z);         // left
  box(new THREE.BoxGeometry(WT,H,D+WT*2),wMat, x+W/2+WT/2,H/2,z);         // right
  box(new THREE.BoxGeometry(fSide,H,WT),wMat, x-DOOR_W/2-fSide/2,H/2,z+D/2+WT/2); // front-L
  box(new THREE.BoxGeometry(fSide,H,WT),wMat, x+DOOR_W/2+fSide/2,H/2,z+D/2+WT/2); // front-R
  box(new THREE.BoxGeometry(W+WT*2,H-DOOR_H,WT),wMat, x,DOOR_H+(H-DOOR_H)/2,z+D/2+WT/2); // front-top

  // â”€â”€ ROOF â€” proper gabled prism via BufferGeometry â”€â”€
  const roofW=W+WT*2+1.5, roofD=D+WT*2+1.5, roofH=H*0.6;
  {
    const hw=roofW/2, hd=roofD/2;
    const verts=new Float32Array([
      -hw,0,-hd,   // 0 left-front base
       hw,0,-hd,   // 1 right-front base
       hw,0, hd,   // 2 right-back base
      -hw,0, hd,   // 3 left-back base
      -hw,roofH,0, // 4 left-ridge
       hw,roofH,0, // 5 right-ridge
    ]);
    const idxArr=new Uint16Array([
      0,4,1, 1,4,5,  // front slope
      2,5,3, 3,5,4,  // back slope
      0,3,4,         // left gable
      1,5,2,         // right gable
      0,1,2, 0,2,3,  // base (for shadows)
    ]);
    const geo=new THREE.BufferGeometry();
    geo.setAttribute('position',new THREE.BufferAttribute(verts,3));
    geo.setIndex(new THREE.BufferAttribute(idxArr,1));
    geo.computeVertexNormals();
    const roofMesh=new THREE.Mesh(geo,rMat);
    roofMesh.position.set(x,H+0.25,z);
    roofMesh.castShadow=true; roofMesh.receiveShadow=true; roofMesh.userData.deco=true;
    scene.add(roofMesh);
  }
  // Eave lip at base of roof
  box(new THREE.BoxGeometry(roofW+.2,0.4,roofD+.2),rMat, x,H+.2,z);
  // Ridge cap
  box(new THREE.BoxGeometry(roofW+0.3,0.3,0.3),rMat, x,H+0.25+roofH,z);

  // â”€â”€ CEILING â”€â”€
  box(new THREE.BoxGeometry(W+.2,.25,D+.2),new THREE.MeshStandardMaterial({color:0xEEEEE8,roughness:.9}), x,H-.12,z);

  // â”€â”€ WINDOWS (embedded in wall â€” frame larger than glass) â”€â”€
  const wY=H*0.62, wW=2.0, wH2=1.7;
  function win(px,pz,ry){
    box(new THREE.BoxGeometry(wW+.5,wH2+.5,WT+.1),frMat,px,wY,pz,ry);
    box(new THREE.BoxGeometry(wW,wH2,WT*.25),winMat,px,wY,pz,ry);
  }
  win(x-W*.25, z-D/2-WT/2, 0); win(x+W*.25, z-D/2-WT/2, 0);
  win(x-W/2-WT/2, z-D*.2, Math.PI/2); win(x-W/2-WT/2, z+D*.2, Math.PI/2);
  win(x+W/2+WT/2, z-D*.2, Math.PI/2); win(x+W/2+WT/2, z+D*.2, Math.PI/2);
  if(fSide>3) win(x-(DOOR_W/2+fSide*.5), z+D/2+WT/2, 0);
  if(fSide>3) win(x+(DOOR_W/2+fSide*.5), z+D/2+WT/2, 0);

  // â”€â”€ DOOR â€” open/ajar to invite entry â”€â”€
  const doorM=box(new THREE.BoxGeometry(DOOR_W-.4,DOOR_H-.4,.12),dMat, x-(DOOR_W*.35),DOOR_H/2,z+D/2+WT*.55);
  doorM.rotation.y=Math.PI*0.3; // swung open

  // â”€â”€ INTERIOR FURNITURE â”€â”€
  box(new THREE.BoxGeometry(4.5,.8,6.5),new THREE.MeshStandardMaterial({color:0x5577AA,roughness:.8}), x+W*.22,.4,z-D*.18);
  box(new THREE.BoxGeometry(3.5,H*.65,1.8),new THREE.MeshStandardMaterial({color:0x7A5525,roughness:.85}), x-W*.28,H*.33,z+D*.2);
  if(idx<5){ // limit interior lights for perf
    const pl=new THREE.PointLight(0xFFCC88,.8,20);
    pl.position.set(x,H-.8,z); pl.userData.deco=true; scene.add(pl);
  }

  // â”€â”€ COLLISION â€” walls only need coverage at player height â”€â”€
  const R=WT+.8;
  for(let i=0;i<=W+WT*2;i+=3) obstacles.push({x:x-W/2-WT+i, z:z-D/2-WT, radius:R}); // back
  for(let i=0;i<=D+WT*2;i+=3) obstacles.push({x:x-W/2-WT,  z:z-D/2-WT+i, radius:R}); // left
  for(let i=0;i<=D+WT*2;i+=3) obstacles.push({x:x+W/2+WT,  z:z-D/2-WT+i, radius:R}); // right
  for(let i=0;i<=fSide;i+=3)   obstacles.push({x:x-W/2+i,   z:z+D/2+WT,   radius:R}); // front-L
  for(let i=0;i<=fSide;i+=3)   obstacles.push({x:x+DOOR_W/2+i, z:z+D/2+WT, radius:R}); // front-R
  obstacles.push({x:x-W*.28, z:z+D*.2, radius:2.0});  // wardrobe
  obstacles.push({x:x+W*.22, z:z-D*.18, radius:2.0}); // bed

  housePositions.push({x,z,w:W+WT*2,d:D+WT*2});
}

function addTree(x,z){
  const ty=terrainH(x,z);
  const trunk=mkMesh(new THREE.CylinderGeometry(.35,.6,5+Math.random()*3,4),{color:0x6b3d1e,roughness:1});
  trunk.position.set(x,ty+3,z); trunk.castShadow=true; trunk.userData.deco=true; scene.add(trunk);
  const cr=3+Math.random()*3;
  const crown=mkMesh(new THREE.SphereGeometry(cr,5,3),{color:0x2d7a20+(Math.floor(Math.random()*4)*0x050000),roughness:1});
  crown.position.set(x,ty+5+cr*.6,z); crown.castShadow=true; crown.userData.deco=true; scene.add(crown);
  obstacles.push({mesh:trunk,radius:1.4,x,z});
}

// â”€â”€ MAP 2: TURTLE BEACH â”€â”€
function buildBeach(){
  // Single ocean plane â€” sits clearly below sand level, no layering
  const ocean=mkMesh(new THREE.PlaneGeometry(3000,1200),{color:0x0d7ab5,roughness:.08,metalness:.2});
  ocean.rotation.x=-Math.PI/2; ocean.position.set(0,-3,0); ocean.userData.deco=true; scene.add(ocean);

  // Wet sand fringe where water meets beach â€” just a thin darker strip, same plane level as terrain
  const wet=mkMesh(new THREE.PlaneGeometry(3000,60),{color:0xd4a84a,roughness:.9});
  wet.rotation.x=-Math.PI/2; wet.position.set(0,0.01,-170); wet.userData.deco=true; scene.add(wet);

  // Ocean only visible south of z=-180 â€” block player from swimming
  // (beach terrain flat, water below it â€” clean edge)

  // Palm trees on dry sand
  for(let i=0;i<70;i++){
    const px=(Math.random()-.5)*700, pz=(Math.random()-.5)*200;
    addPalm(px,pz);
  }

  // Tall grass tufts on beach
  spawnBeachGrass(80,600,180);

  // Beach umbrellas and towels
  for(let i=0;i<20;i++) addUmbrella((Math.random()-.5)*500,(Math.random()-.5)*200);

  // Rocks/tide pools â€” keep on dry sand
  for(let i=0;i<20;i++){
    const s=Math.random()*3+.8;
    const rx=(Math.random()-.5)*600, rz=(Math.random()-.5)*220;
    const rock=mkMesh(new THREE.SphereGeometry(s,5,4),{color:0xB0A090,roughness:.95});
    rock.position.set(rx,terrainH(rx,rz)+s*.4,rz); rock.castShadow=true; rock.userData.deco=true; scene.add(rock);
    obstacles.push({mesh:rock,radius:s*1.2,x:rx,z:rz});
  }

  // Sand dunes
  for(let i=0;i<20;i++){
    const dx=(Math.random()-.5)*600, dz=(Math.random()-.5)*220;
    const dune=mkMesh(new THREE.SphereGeometry(8+Math.random()*14,8,6),{color:0xe8c870,roughness:1});
    dune.scale.y=.22; dune.position.set(dx,.2,dz); dune.receiveShadow=true; dune.userData.deco=true; scene.add(dune);
  }

  // Turtle shells (decorative)
  for(let i=0;i<14;i++){
    const sx=(Math.random()-.5)*500, sz=(Math.random()-.5)*200;
    addShell(sx,sz);
  }

  spawnFamily();
}

function spawnBeachGrass(count,spreadX,spreadZ){
  // Beach grass â€” yellowish sea grass tufts
  const gm=new THREE.MeshStandardMaterial({color:0xc8c040,side:THREE.DoubleSide,transparent:true,alphaTest:.08,roughness:1});
  for(let i=0;i<count;i++){
    const gx=(Math.random()-.5)*spreadX, gz=(Math.random()-.5)*spreadZ;
    const g=new THREE.Mesh(new THREE.PlaneGeometry(1.2+Math.random()*.8,2+Math.random()*1.5),gm);
    g.position.set(gx,terrainH(gx,gz)+1+Math.random()*.5,gz);
    g.rotation.y=Math.random()*Math.PI;
    scene.add(g); grassBlades.push(g);
  }
}

function addPalm(x,z){
  const ty=terrainH(x,z);
  const trunk=mkMesh(new THREE.CylinderGeometry(.25,.5,8+Math.random()*4,6),{color:0x9b7845,roughness:1});
  trunk.position.set(x,ty+5,z); trunk.rotation.z=(Math.random()-.5)*.3; trunk.castShadow=true; trunk.userData.deco=true; scene.add(trunk);
  const top=mkMesh(new THREE.SphereGeometry(3.5,8,5),{color:0x2ea020+(Math.floor(Math.random()*3)*0x030000),roughness:1});
  top.scale.y=.3; top.position.set(x+Math.sin(trunk.rotation.z)*8,ty+10,z); top.userData.deco=true; scene.add(top);
  obstacles.push({mesh:trunk,radius:1.2,x,z});
}

function addUmbrella(x,z){
  const ty=terrainH(x,z);
  const pole=mkMesh(new THREE.CylinderGeometry(.08,.08,4,5),{color:0xaaaaaa});
  pole.position.set(x,ty+2,z); pole.userData.deco=true; scene.add(pole);
  const cols=[0xff4444,0xffcc00,0x44aaff,0xff8800,0xff44ff,0x44ff88];
  const canopy=mkMesh(new THREE.ConeGeometry(3.2,1.2,8),{color:cols[Math.floor(Math.random()*cols.length)]});
  canopy.rotation.x=Math.PI; canopy.position.set(x,ty+4.2,z); canopy.userData.deco=true; scene.add(canopy);
  // Towel
  const towel=mkMesh(new THREE.BoxGeometry(3.5,.05,5),{color:cols[Math.floor(Math.random()*cols.length)],roughness:.9});
  towel.position.set(x+(Math.random()-.5)*4,ty+.06,z+(Math.random()-.5)*4); towel.userData.deco=true; scene.add(towel);
}

function addShell(x,z){
  const ty=terrainH(x,z);
  const shell=mkMesh(new THREE.SphereGeometry(1.2,6,5),{color:0x8B6914,roughness:.9});
  shell.scale.y=.55; shell.position.set(x,ty+.5,z); shell.userData.deco=true; scene.add(shell);
}

// â”€â”€ MAP 3: CLASSROOM â”€â”€
function buildClassroom(){
  const W=80, D=60, H=9, WT=1.5;
  const wMat=new THREE.MeshStandardMaterial({color:0xF2EFE8,roughness:.85});
  const fMat=new THREE.MeshStandardMaterial({color:0xD4C4A0,roughness:.65});

  function cbox(geo,mat,px,py,pz){
    const m=new THREE.Mesh(geo,mat);
    m.position.set(px,py,pz);
    m.castShadow=true; m.receiveShadow=true; m.userData.deco=true; scene.add(m); return m;
  }

  // â”€â”€ FLOOR SLAB â€” thick enough to cover terrain â”€â”€
  cbox(new THREE.BoxGeometry(W+WT*2,8,D+WT*2),fMat, 0,-3.5,0);
  // Interior floor surface (slightly lighter)
  cbox(new THREE.BoxGeometry(W-.5,.15,D-.5),new THREE.MeshStandardMaterial({color:0xDDD0B0,roughness:.6}), 0,.07,0);

  // â”€â”€ 4 SOLID WALLS with GUARANTEED collision â”€â”€
  // Back wall
  cbox(new THREE.BoxGeometry(W+WT*2,H,WT),wMat, 0,H/2,-D/2-WT/2);
  for(let ix=-W/2-WT;ix<=W/2+WT;ix+=2.5) obstacles.push({x:ix,z:-D/2-WT/2,radius:WT+.9});
  // Front wall
  cbox(new THREE.BoxGeometry(W+WT*2,H,WT),wMat, 0,H/2,D/2+WT/2);
  for(let ix=-W/2-WT;ix<=W/2+WT;ix+=2.5) obstacles.push({x:ix,z:D/2+WT/2,radius:WT+.9});
  // Left wall
  cbox(new THREE.BoxGeometry(WT,H,D+WT*2),wMat, -W/2-WT/2,H/2,0);
  for(let iz=-D/2-WT;iz<=D/2+WT;iz+=2.5) obstacles.push({x:-W/2-WT/2,z:iz,radius:WT+.9});
  // Right wall
  cbox(new THREE.BoxGeometry(WT,H,D+WT*2),wMat, W/2+WT/2,H/2,0);
  for(let iz=-D/2-WT;iz<=D/2+WT;iz+=2.5) obstacles.push({x:W/2+WT/2,z:iz,radius:WT+.9});

  // â”€â”€ CEILING â”€â”€
  cbox(new THREE.BoxGeometry(W+WT*2,.3,D+WT*2),new THREE.MeshStandardMaterial({color:0xF5F5F0,roughness:.9}), 0,H+.15,0);

  // â”€â”€ BLACKBOARD â”€â”€
  cbox(new THREE.BoxGeometry(32,6,.6),new THREE.MeshStandardMaterial({color:0x1B5E30,roughness:.75}), 0,5,-D/2+WT*.4);
  cbox(new THREE.BoxGeometry(33,6.6,.3),new THREE.MeshStandardMaterial({color:0x8B6535,roughness:.85}), 0,5,-D/2+WT*.1);
  for(let i=0;i<4;i++){
    cbox(new THREE.BoxGeometry(6+Math.random()*3,.15,.1),
      new THREE.MeshStandardMaterial({color:0xF5F5F5,emissive:0xEEEEEE,emissiveIntensity:.12}),
      -12+i*8, 4.5+Math.random()*2, -D/2+WT*.5);
  }

  // â”€â”€ DESKS: 4 rows x 4 cols (smaller room = fewer desks) â”€â”€
  for(let row=0;row<4;row++) for(let col=0;col<4;col++) addDesk(-24+col*16,-20+row*12);
  addDesk(0,-D/2+8,true); // teacher desk near board

  // â”€â”€ BOOKSHELVES â”€â”€
  [-37,37].forEach(sx=>{
    cbox(new THREE.BoxGeometry(WT+.5,7,D*.65),new THREE.MeshStandardMaterial({color:0x8B6535,roughness:.9}), sx,3.5,2);
    for(let sz=-D*.32;sz<=D*.32;sz+=2.5) obstacles.push({x:sx,z:2+sz,radius:WT+1.0});
    const bookCols=[0xCC2222,0x2255CC,0x22AA44,0xCC8822,0x884499,0x226688,0xAA3355,0x558833];
    for(let b=0;b<12;b++){
      cbox(new THREE.BoxGeometry(.35,1.3+Math.random()*.3,.65),
        new THREE.MeshStandardMaterial({color:bookCols[b%8],roughness:.85}),
        sx+(sx>0?-.5:.5), .7+b*.55, -18+b*3);
    }
  });

  // â”€â”€ CEILING LIGHTS â”€â”€
  for(let i=0;i<3;i++){
    const bx=-20+i*20;
    cbox(new THREE.BoxGeometry(10,.2,.4),new THREE.MeshStandardMaterial({color:0xEEEECC,emissive:0xDDDDAA,emissiveIntensity:1.1}), bx,H-.15,0);
    const pl=new THREE.PointLight(0xFFF8EE,2.0,28);
    pl.position.set(bx,H-1,0); pl.userData.deco=true; pl.castShadow=false; scene.add(pl);
  }

  // â”€â”€ WINDOWS â”€â”€
  const winMat2=new THREE.MeshStandardMaterial({color:0x88CCFF,transparent:true,opacity:.5,roughness:.05});
  [-18,0,18].forEach(wz=>{
    cbox(new THREE.BoxGeometry(WT+.1,3.5,4.5),winMat2, W/2+WT/2,5.5,wz);
    cbox(new THREE.BoxGeometry(WT+.5,4,5),new THREE.MeshStandardMaterial({color:0xDDDDDD,roughness:.8}), W/2+WT/2,5.5,wz);
  });

  // â”€â”€ GLOBE â”€â”€
  cbox(new THREE.BoxGeometry(.2,2.5,.2),new THREE.MeshStandardMaterial({color:0x888888}), 8,1.5,-D/2+10);
  cbox(new THREE.SphereGeometry(1.4,8,6),new THREE.MeshStandardMaterial({color:0x3388EE,roughness:.35}), 8,3.8,-D/2+10);

  // â”€â”€ SPAWN TINY â€” guaranteed synchronous placement â”€â”€
  // Tiny hides behind teacher desk or in bookshelf corner
  const TINY_SPOTS=[[0,-D/2+9],[32,2],[-32,2],[20,-22],[-20,-22]];
  const spot=TINY_SPOTS[Math.floor(Math.random()*TINY_SPOTS.length)];
  const tinyMat=new THREE.MeshStandardMaterial({color:typeCol('tiny'),side:THREE.DoubleSide,transparent:true,alphaTest:.05});
  tLoader.load('tiny.png',tex=>{tinyMat.map=tex;tinyMat.color.set(0xFFFFFF);tinyMat.needsUpdate=true;},null,()=>{});
  const tinyMesh=new THREE.Mesh(new THREE.PlaneGeometry(1.0,1.3),tinyMat);
  tinyMesh.position.set(spot[0],1.0,spot[1]);
  tinyMesh.castShadow=true; scene.add(tinyMesh);
  familyMeshes.push({mesh:tinyMesh,type:'tiny'});
}

function addDesk(x,z,big=false){
  const s=big?1.6:1;
  const desk=mkMesh(new THREE.BoxGeometry(7*s,.25,4*s),{color:0xc8a060,roughness:.8}); desk.position.set(x,1.6,z); desk.castShadow=desk.receiveShadow=true; desk.userData.deco=true; scene.add(desk);
  [[-2.8,-.8],[2.8,-.8],[-2.8,1.5],[2.8,1.5]].forEach(([ox,oz])=>{
    const leg=mkMesh(new THREE.CylinderGeometry(.15,.15,1.6,4),{color:0x7a5020}); leg.position.set(x+ox*s,1,z+oz*s); leg.userData.deco=true; scene.add(leg);
  });
  // Paper on desk
  if(!big){ const paper=mkMesh(new THREE.BoxGeometry(2,.03,2.5),{color:0xfafafa,roughness:.9}); paper.position.set(x,1.76,z); paper.userData.deco=true; scene.add(paper); }
  obstacles.push({mesh:desk,radius:big?5.5:3.2,x,z});
}

function spawnGrass(count,spread){
  const gm=new THREE.MeshStandardMaterial({color:0x2a8a22,side:THREE.DoubleSide,transparent:true,alphaTest:.1});
  for(let i=0;i<count;i++){
    const g=new THREE.Mesh(new THREE.PlaneGeometry(1.5+Math.random(),3+Math.random()*2),gm);
    const gx=(Math.random()-.5)*spread,gz=(Math.random()-.5)*spread;
    g.position.set(gx,terrainH(gx,gz)+1.5+Math.random(),gz); g.rotation.y=Math.random()*Math.PI;
    g.castShadow=false; scene.add(g); grassBlades.push(g);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONTROLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const moveK={w:false,a:false,s:false,d:false};
const camK={ArrowLeft:false,ArrowRight:false,ArrowUp:false,ArrowDown:false};

window.addEventListener('keydown',e=>{
  const k=e.key;
  if(k in moveK) moveK[k]=true;
  if(k in camK){ camK[k]=true; e.preventDefault(); }
  if(k===' ') doJump();
  if(k==='c'||k==='C'){ isCrouching=true; }
  if(k==='Escape') togglePause();
  if((k==='f'||k==='F')&&(accessMode==='dev'||accessMode==='admin')){ flyMode=!flyMode; showToast(flyMode?'Fly ON':'Fly OFF'); }
  if((k==='r'||k==='R')&&(accessMode==='dev'||accessMode==='admin')){ player.position.set(0,20,0); showToast('Position reset'); }
  if((k==='g'||k==='G')&&accessMode!=='normal') adminCollect();
  if((k==='n'||k==='N')&&accessMode==='dev'){ noclipMode=!noclipMode; showToast(noclipMode?'Noclip ON':'Noclip OFF'); }
  if((k==='z'||k==='Z')&&accessMode==='dev'){ superSpeed=!superSpeed; showToast(superSpeed?'Super Speed ON':'Super Speed OFF'); }
});
window.addEventListener('keyup',e=>{ const k=e.key; if(k in moveK)moveK[k]=false; if(k in camK)camK[k]=false; if(k==='c'||k==='C') isCrouching=false; });

// Joystick â€” direction relative to camera
let joyX=0,joyY=0,joyActive=false,joyC={x:0,y:0};
const GRAVITY=.024,JUMP_V=.55,SPEED=.38;

const joyOuter=document.getElementById('joy-outer');
const joyInner=document.getElementById('joy-inner');
joyOuter.addEventListener('touchstart',e=>{ joyActive=true; const r=joyOuter.getBoundingClientRect(); joyC={x:r.left+65,y:r.top+65}; joyMove(e.touches[0]); },{passive:true});
joyOuter.addEventListener('touchmove',e=>{ if(joyActive){e.preventDefault();joyMove(e.touches[0]);} },{passive:false});
joyOuter.addEventListener('touchend',()=>{ joyActive=false; joyX=joyY=0; joyInner.style.transform='translate(0,0)'; });
function joyMove(t){
  let dx=t.clientX-joyC.x,dy=t.clientY-joyC.y;
  const d=Math.sqrt(dx*dx+dy*dy),m=42;
  if(d>m){dx=dx/d*m;dy=dy/d*m;}
  joyInner.style.transform=`translate(${dx}px,${dy}px)`;
  joyX=dx/m; joyY=dy/m;
}
document.getElementById('jump-btn').addEventListener('touchstart',e=>{e.preventDefault();doJump();});
const crouchBtn=document.getElementById('crouch-btn');
crouchBtn.addEventListener('touchstart',e=>{e.preventDefault();isCrouching=true;});
crouchBtn.addEventListener('touchend',e=>{e.preventDefault();isCrouching=false;});
function doJump(){ if(flyMode){flyVelY=.6;return;} if(isGrounded){velocityY=JUMP_V;isGrounded=false;} }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HUD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateHUD(){
  // Show cumulative found / total across all maps
  document.getElementById('c-dad').textContent=`Dad ${famFound.dad}/${famTargets.dad}`;
  document.getElementById('c-mum').textContent=`Mum ${famFound.mum}/${famTargets.mum}`;
  document.getElementById('c-bro').textContent=`Bros ${famFound.brother}/${famTargets.brother}`;
  document.getElementById('c-sis').textContent=`Sis ${famFound.sister}/${famTargets.sister}`;
  document.getElementById('c-tiny').textContent=`Tiny ${famFound.tiny}/${famTargets.tiny}`;
  // Unlock map 3 label
  const nt=famFound.dad+famFound.mum+famFound.brother+famFound.sister;
  const tot=famTargets.dad+famTargets.mum+famTargets.brother+famTargets.sister;
  if(nt>=tot){ const o=document.querySelector('#map-sel option[value="3"]'); if(o&&o.textContent.includes('ğŸ”’')) o.textContent="ğŸ« Map 3 â€” Tiny's Hideout"; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  COLLECTION & UNLOCK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•







function checkGroupUnlock(type){
  if(groupUnlocked[type]) return;
  if(famFound[type]>=famTargets[type]){
    groupUnlocked[type]=true;
    if(!unlockedSkins.includes(type)){
      unlockedSkins.push(type);
      saveUnlocked();        // persist to localStorage
      buildSkinSel();        // update in-game switcher
      buildSpritePicker();   // update menu picker (unlocks sprite)
      showUnlockBanner(type);
    }
  }
}
function checkWin(){
  if(famFound.dad+famFound.mum+famFound.brother+famFound.sister+famFound.tiny>=20){
    setTimeout(()=>alert(`ğŸ‰ You found the WHOLE family!\n${document.getElementById('timer-tag').textContent}\nAmazing work!`),400);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MAP GATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function tryMap(v){
  v=parseInt(v);
  if(v===3&&accessMode==='normal'){
    const nf=famFound.dad+famFound.mum+famFound.brother+famFound.sister;
    const nt=famTargets.dad+famTargets.mum+famTargets.brother+famTargets.sister;
    if(nf<nt){ showLocked("Find all of Dad, Mum, Brothers & Sisters first!\n(Across Maps 1 & 2)\nThen Tiny's Hideout unlocks ğŸ”’"); document.getElementById('map-sel').value=currentMap; return; }
  }
  currentMap=v; loadMap(v);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let lastT=0;
let frameCount=0;
function animate(ts=0){
  frameCount++;
  requestAnimationFrame(animate);
  const dt=Math.min((ts-lastT)/1000,.05); lastT=ts;
  if(gamePaused) return;

  // â”€â”€ Day/Night cycle â€” skipped entirely in battery saver â”€â”€
  let sunH=0.9; // battery saver default: bright midday
  if(!batterySaver){
    dayT+=DAY_SPEED;
    const sinT=Math.sin(dayT), cosT=Math.cos(dayT);
    sunH=Math.max(0,sinT);
    if(Math.abs(sunH-lastSunH)>.002){ updateSky(sunH,sinT); lastSunH=sunH; }
    skyMesh.position.copy(camera.position);
    sun.position.set(cosT*300,sinT*300,80);
    sun.intensity=sunH*2.2+.05;
    if(sunH>0.01) sun.color.setHSL(0.10-sunH*0.05,1.0,Math.max(0.45,0.55+sunH*0.1));
    else sun.color.setHSL(0.62,0.4,0.15);
    const nightBlue=new THREE.Color(0x050520);
    const dawnOrange=new THREE.Color(0xff6600);
    const dayBlue=new THREE.Color(currentMap===2?0x55aaff:0x4499ee);
    const horizCol = sunH>0.01 ? new THREE.Color(0xff7700).lerp(new THREE.Color(0xbbddff),Math.min(1,sunH*2)) : new THREE.Color(0x1a0808);
    scene.fog.color.copy(horizCol);
    if(currentMap!==3) scene.fog.density=Math.max(.001,.0017-sunH*.0006);
    ambient.intensity=Math.max(.05,sunH*.3);
    hemiLight.intensity=Math.max(.1,sunH*1.1);
    fillLight.intensity=Math.max(0,.4-sunH*.5);
    fillLight.color.set(sunH<.1?0x8899ff:0x4488ff);
    cloudMeshes.forEach(c=>{ c.position.x+=c.userData.speed*c.userData.dir; if(Math.abs(c.position.x)>600) c.userData.dir*=-1; });
  }

  // Camera keys
  if(camK.ArrowLeft)  camYaw  +=CAM_SPD;
  if(camK.ArrowRight) camYaw  -=CAM_SPD;
  if(camK.ArrowUp)    camPitch =clamp(camPitch+CAM_SPD,.05,1.45);
  if(camK.ArrowDown)  camPitch =clamp(camPitch-CAM_SPD,.05,1.45);

  // Movement â€” camera-relative, joystick follows camera direction
  let mx=0,mz=0;
  const fwd=new THREE.Vector3(-Math.sin(camYaw),0,-Math.cos(camYaw));
  const rgt=new THREE.Vector3( Math.cos(camYaw),0,-Math.sin(camYaw));
  if(joyActive){
    // Joystick: forward = camera forward
    mx+=fwd.x*joyY*SPEED+rgt.x*joyX*SPEED;
    mz+=fwd.z*joyY*SPEED+rgt.z*joyX*SPEED;
    // Note: joyY negative = push up = move forward
    const jSPD=superSpeed?SPEED*4:SPEED;
    mx=-fwd.x*joyY*jSPD+rgt.x*joyX*jSPD;
    mz=-fwd.z*joyY*jSPD+rgt.z*joyX*jSPD;
  } else {
    const SPD=superSpeed?SPEED*4:SPEED;
    if(moveK.w){mx+=fwd.x*SPD;mz+=fwd.z*SPD;}
    if(moveK.s){mx-=fwd.x*SPD;mz-=fwd.z*SPD;}
    if(moveK.a){mx-=rgt.x*SPD;mz-=rgt.z*SPD;}
    if(moveK.d){mx+=rgt.x*SPD;mz+=rgt.z*SPD;}
  }

  const nx=player.position.x+mx, nz=player.position.z+mz;
  let hit=false;
  if(!noclipMode && !(accessMode==='dev'&&flyMode)){
    const px2=player.position.x, pz2=player.position.z;
    for(const r of obstacles){
      // Quick broad-phase: skip if more than radius+4 away on either axis
      const rdx=Math.abs(nx-r.x), rdz=Math.abs(nz-r.z), rr=r.radius+1.0;
      if(rdx>rr+2||rdz>rr+2) continue;
      if(rdx*rdx+rdz*rdz<rr*rr){hit=true;break;}
    }
  }
  if(!hit){player.position.x=nx;player.position.z=nz;}

  // Physics
  const tH=terrainH(player.position.x,player.position.z);
  if(flyMode){
    flyVelY*=.9; player.position.y+=flyVelY;
    if(player.position.y<tH+1.2) player.position.y=tH+1.2;
    isGrounded=false;
  } else {
    if(!isGrounded){ player.position.y+=velocityY; velocityY-=GRAVITY; if(player.position.y<=tH+1.2){player.position.y=tH+1.2;isGrounded=true;velocityY=0;} }
    else{ player.position.y=tH+1.2; }
  }
  disc.position.set(player.position.x,tH+.04,player.position.z);

  // Billboards
  const cfx=camera.position.x,cfz=camera.position.z;
  player.lookAt(cfx,player.position.y,cfz);
  familyMeshes.forEach(f=>f.mesh.lookAt(cfx,f.mesh.position.y,cfz));
  for(const id in peers) peers[id].mesh.lookAt(cfx,peers[id].mesh.position.y,cfz);

  // Grass sway â€” skip in battery mode (saves ~1ms/frame with 80 blades)
  if(!batterySaver){
    const t2=ts*.001;
    grassBlades.forEach((g,i)=>{ g.rotation.z=Math.sin(t2*1.4+i*.7)*.09; });
  }

  doUpdateCamera();
  // Labels: every frame normally, every 3 frames in battery mode
  if(!batterySaver||frameCount%3===0){
    label3D(player,document.getElementById('name-label'));
    for(const id in peers) label3D(peers[id].mesh,peers[id].labelDiv);
  }

  // Collection â€” larger range for hard maps
  const collectR=2.6;
  for(let i=familyMeshes.length-1;i>=0;i--){
    const f=familyMeshes[i];
    if(player.position.distanceTo(f.mesh.position)<collectR){
      scene.remove(f.mesh); famFound[f.type]++; familyMeshes.splice(i,1);
      updateHUD(); checkGroupUnlock(f.type); checkWin();
    }
  }

  // Net sync â€” battery saver sends every 6 frames, normal every 2
  netSyncCounter++;
  const syncRate = batterySaver ? 6 : 2;
  if(netSyncCounter%syncRate===0){
    for(const id in peers){ const p=peers[id]; if(p.conn&&p.conn.open) p.conn.send({type:'move',x:player.position.x,y:player.position.y,z:player.position.z}); }
  }

  // Dev panel
  if(accessMode==='dev'){
    const pp=player.position;
    document.getElementById('dev-panel').textContent=
      `POS(${pp.x.toFixed(0)},${pp.y.toFixed(0)},${pp.z.toFixed(0)}) CAM yaw:${(camYaw*57.3).toFixed(0)}Â° pitch:${(camPitch*57.3).toFixed(0)}Â°\n`+
      `Family left:${familyMeshes.length}  Map:${currentMap}  Fly:${flyMode?'ON':'OFF'}  Skin:${currentSkin}\n`+
      `[F]fly [R]reset [G]collect [â†â†’â†‘â†“]camera`;
  }

  renderer.render(scene,camera);
}

function label3D(mesh,el){
  const v=mesh.position.clone(); v.y+=2; v.project(camera);
  if(v.z>1){el.style.display='none';return;}
  el.style.left=`${(v.x*.5+.5)*innerWidth}px`; el.style.top=`${(v.y*-.5+.5)*innerHeight}px`; el.style.display='block';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UI HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showLocked(t){ const el=document.getElementById('locked-msg'); el.innerHTML='ğŸ”’ '+t.replace(/\n/g,'<br>'); el.style.display='block'; clearTimeout(el._t); el._t=setTimeout(()=>el.style.display='none',3500); }
function showUnlockBanner(type){
  const el=document.getElementById('unlock-banner'); const src=SKIN_IMGS[type]||'';
  el.innerHTML=`<div style="font-size:2.2rem">ğŸ‰ Group Found!</div>${src?`<img src="${src}" onerror="this.style.display='none'" style="object-fit:cover">`:''}  <div style="font-size:1.1rem">All <b>${type}s</b> found!<br><span style="font-size:.85rem;opacity:.8">New skin unlocked!</span></div>`;
  el.style.display='block'; clearTimeout(el._t); el._t=setTimeout(()=>el.style.display='none',4000);
}
function showToast(msg,dur=2800){ const el=document.getElementById('toast'); el.textContent=msg; el.style.display='block'; clearTimeout(el._t); el._t=setTimeout(()=>el.style.display='none',dur); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TIMER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startTimer(){ if(timerInterval)clearInterval(timerInterval); secondsElapsed=0; timerInterval=setInterval(()=>{ secondsElapsed++; const m=Math.floor(secondsElapsed/60).toString().padStart(2,'0'),s=(secondsElapsed%60).toString().padStart(2,'0'); document.getElementById('timer-tag').textContent=m+':'+s; },1000); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  START GAME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startGame(){
  playerName=document.getElementById('inp-name').value.trim()||'Explorer';
  const nameLabel=document.getElementById('name-label');
  nameLabel.innerText=playerName;
  if(accessMode==='admin') nameLabel.classList.add('fname-admin');
  if(accessMode==='dev')   nameLabel.classList.add('fname-dev');

  updateModeTag();
  initNet(document.getElementById('inp-room').value.trim());

  document.getElementById('menu').style.opacity='0';
  setTimeout(()=>{
    document.getElementById('menu').style.display='none';
    document.getElementById('hud').style.display='block';
    document.getElementById('top-right').style.display='flex';
    document.getElementById('name-label').style.display='block';
    document.getElementById('pause-btn').style.display='block';
    document.getElementById('joy-wrap').style.display='block';
    document.getElementById('jump-btn').style.display='block';
    document.getElementById('crouch-btn').style.display='block';
    document.getElementById('cam-hint').style.display='block';
    document.getElementById('skin-sel').style.display='flex';
    document.getElementById('dialogue').style.display='flex';
    // Update dialogue image + name to match the player's chosen sprite
    const dImg = document.getElementById('d-img');
    dImg.src = currentSkin + '.png';
    dImg.onerror = function(){
      this.onerror=null; this.style.visibility='hidden';
      this.style.background=SPRITE_FALLBACK_COLORS[currentSkin]||'#4ECDC4';
    };
    document.querySelector('#dialogue .d-name').textContent = (currentSkin[0].toUpperCase()+currentSkin.slice(1)) + ' ğŸ¢';

    // Skin: use chosen sprite only if it is actually unlocked, else fall back to friend
    currentSkin=unlockedSkins.includes(chosenSprite)?chosenSprite:'friend';
    // Do NOT add chosen sprite to unlocked here â€” it must be earned (except friend)
    currentMap=1; loadMap(1);
    buildSkinSel(); applySkin(currentSkin);
    startTimer(); gameStarted=true; animate();

    setTimeout(()=>document.getElementById('cam-hint').style.display='none',8000);
  },600);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UTILS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function clamp(v,mn,mx){ return Math.max(mn,Math.min(mx,v)); }

window.addEventListener('resize',()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });
</script>
</body>
</html>
